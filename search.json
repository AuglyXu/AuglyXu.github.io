[{"title":"Markdown渲染工具——markdown-it","url":"/2025/04/30/Markdown%E6%B8%B2%E6%9F%93%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94markdown-it/","content":""},{"title":"AI大模型数据流SSE处理工具——fetch-event-source","url":"/2025/04/13/AI%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%B5%81%E2%80%94%E2%80%94SSE/","content":"前言最近项目需求，开发与AI相关的功能，接触到一些AI大模型相关的技术，其中前端处理大模型返回的数据流是必不可少的一环，流式SSE处理工具fetch-event-source，可以很好的解决这个问题。\n其次 MCP 也定义了两种标准的数据格式，stdio以及sse，其中stdio是标准输入输出(对本地集成和命令行工具特别有用)，sse是服务器发送事件，这两种数据格式在AI大模型中非常常见。\n什么是SSESSE(Server-Sent Events)是一种服务器向浏览器发送事件的机制。它允许服务器向浏览器发送实时数据，而不需要浏览器发起请求。SSE是一种单向的、基于HTTP的协议，适用于需要实时数据传输的场景。\n传统处理方式浏览器内置EventSource对象，可以很方便的实现SSE处理。不过这个EventSource有一个非常致命的缺点，那就是只支持GET类型的请求，并且不支持任何自定义的头部。需要与业务交互，显然是不可接受的。\nEventSource官方链接\nconst response = await fetch(url, &#123;    method: 'GET',    headers: &#123;        'Content-Type': 'text/event-stream',    &#125;,&#125;);\n\n@microsoft/fetch-event-source@microsoft/fetch-event-source 是一个用于处理服务器发送事件（SSE）的工具，它提供了一种方便的方式来接收和处理来自服务器的实时数据流。这个包的主要作用是提供一个遵循 WHATWG Fetch 标准的 API 来处理 SSE。实际上目前的ChatGPT实现的双向信息流也是基于这个库进行开发的\n\n允许我们可以和对应的url地址简历持久连接\n\n允许我们在接收数据流信息的同时将我们想要发送的消息也通过相同的url进行发送\n\n\n安装npm install @microsoft/fetch-event-source\n\n使用import &#123; fetchEventSource &#125; from '@microsoft/fetch-event-source';fetchEventSource(url, &#123;    onmessage: (event) =&gt; &#123;        console.log(event);    &#125;,&#125;);\n\n简单封装封装参考开源项目 Wren AI\nimport &#123; EventStreamContentType, fetchEventSource &#125; from '@microsoft/fetch-event-source';commonSseProcess(\t\turl: string,\t\tparams: &#123;\t\t\toptions: any;\t\t\tsignal?: AbortSignal;\t\t\tstartCallback: (chunk: string) =&gt; void;\t\t\tmessageRecived: (chunk: string, eventName?: string) =&gt; void;\t\t\tdoneCallback: (chunk: string) =&gt; void;\t\t\terrorCallback: (error: string) =&gt; void;\t\t&#125;,\t) &#123;\t\tfetchEventSource(url, &#123;\t\t\tmethod: 'POST',\t\t\theaders: &#123;\t\t\t\t'Content-Type': 'application/json',\t\t\t&#125;,\t\t\tsignal: params.signal,\t\t\tbody: JSON.stringify(&#123;\t\t\t\t...params.options,\t\t\t&#125;),\t\t\tonopen: async (response) =&gt; &#123;\t\t\t\tconst resStatus = response.status;\t\t\t\tconst resStatusText = response.statusText;\t\t\t\tif (response.ok &amp;&amp; response.headers.get('content-type') === EventStreamContentType) &#123;\t\t\t\t\t// everything's good\t\t\t\t&#125; else &#123;\t\t\t\t\tthis.createErrorPromise(resStatus, resStatusText, response);\t\t\t\t&#125;\t\t\t&#125;,\t\t\tonmessage(eventMessage) &#123;\t\t\t\tif (eventMessage.event === 'START') &#123;\t\t\t\t\tparams.startCallback(eventMessage.data);\t\t\t\t\treturn;\t\t\t\t&#125; else if (eventMessage.event === 'ERROR') &#123;\t\t\t\t\tconsole.log(`error:$&#123;eventMessage&#125;`);\t\t\t\t\tparams.errorCallback(eventMessage.data);\t\t\t\t\treturn;\t\t\t\t&#125; else if (eventMessage.event === 'END') &#123;\t\t\t\t\tparams.doneCallback(eventMessage.data);\t\t\t\t\treturn;\t\t\t\t&#125;\t\t\t\t// 会自动处理后端返回内容的首个空格，需在后端的返回内容前多加个空格，相关源码：https://github.com/Azure/fetch-event-source/blob/45ac3cfffd30b05b79fbf95c21e67d4ef59aa56a/src/parse.ts#L129-L133\t\t\t\tparams.messageRecived(eventMessage.data, eventMessage.event);\t\t\t&#125;,\t\t\tonerror(error) &#123;\t\t\t\tconsole.log(`sse error:$&#123;error&#125;`);\t\t\t\tparams.errorCallback(error);\t\t\t\tthrow error;\t\t\t&#125;,\t\t\topenWhenHidden: true,\t\t&#125;);\t&#125;\n\n注意点\n后端返回的数据流&lt;field&gt;:&lt;value&gt; fetch-event-source只会处理冒号，后端返回的数据流为&lt;field&gt;：&lt;value&gt;，后端会处理冒号和冒号后面的空格\n\n相关源码：\nhttps://github.com/Azure/fetch-event-source/blob/45ac3cfffd30b05b79fbf95c21e67d4ef59aa56a/src/parse.ts#L129-L133\n\n当响应结果的content中包含有多行文本时，SSE会将包含有换行符的那一行内容替换为空字符串，故需要先将换行符与后面的内容拆分并转成，前端碰到换行标志时转成换行符处理messageRecived: (chunk: string, eventName: STREAM_EVENT) =&gt; &#123;    const &#123; question &#125; = options || &#123;&#125;;    /**     * 当响应结果的content中包含有多行文本时，     * SSE会将包含有换行符的那一行内容替换为空字符串，     * 故需要先将换行符与后面的内容拆分并转成，前端碰到换行标志时转成换行符处理     */    const processedChunk = chunk ? chunk.replace('-_-_wrap_-_-', '\\r\\n') : chunk;    if (onMessage) onMessage(processedChunk, eventName, conversationId, question);    try &#123;        const parsedData = JSON.parse(processedChunk);        setData(parsedData as T);    &#125; catch (e) &#123;        console.error('解析SSE消息失败:', e);    &#125;&#125;,\n这个问题非常的隐蔽且难以理解，问题过程如下(后续会解释一下源码里的处理流程)假设服务器发送了这样的数据：data: Hello\\nWorld\n根据 SSE (Server-Sent Events) 规范，当数据中包含换行符 \\n 时，应该被拆分成多个 “data:” 行发送：data: Hellodata: World\n\n\n\n让我们看看数据是如何在代码中流动的：\n首先在 getLines 函数中：\ngetLines源码\n// 当检测到换行符时，会将数据切分成行case ControlChars.NewLine:    lineEnd = position;    break;\n然后在 getMessages 函数中：\ngetMessages源码\ncase 'data':    message.data = message.data        ? message.data + '\\n' + value        : value;    break;\n问题就出在这里：\n当第一行 data: Hello 到达时：message.data 为空，所以 message.data = “Hello”\n当第二行 data: World 到达时：message.data 已经有值，所以执行 message.data + ‘\\n’ + value\n变成 “Hello\\nWorld”\n但是由于 SSE 的处理机制，这个包含换行符的内容可能会被错误地解析，导致内容被清空或丢失。\n@microsoft/fetch-event-source 源码解析1. 核心方法fetchEventSource核心方法源码\n入参fetchEventSource(input: RequestInfo, &#123; // input为请求的url地址，后续fetch(input, ...)    signal: inputSignal, // 请求的信号，用于取消请求    headers: inputHeaders, // 请求的头部，用于设置请求的头部    onopen: inputOnOpen, // 请求打开时的回调    onmessage, // 收到消息时的回调    onclose, // 请求关闭时的回调    onerror, // 请求错误时的回调    openWhenHidden,    fetch: inputFetch, // 请求的fetch方法，用于自定义请求    ...rest // 其他参数&#125;: FetchEventSourceInit)\n\n其中openWhenHidden的默认值为false，if false, 后续 document.addEventListener(&#39;visibilitychange&#39;, onVisibilityChange);\nfunction onVisibilityChange() &#123;    curRequestController.abort(); // 每次可见性变化时关闭现有的请求    if (!document.hidden) &#123;        create(); // 页面现在可见，重新创建请求。    &#125;&#125;\n\n数据处理数据处理主要是getBytes  getLines getMessages，整个代码的核心部分像是一个洋葱圈模型，分别使用闭包记录了每一层的数据，从文本 -&gt; 行 -&gt; 消息\nawait getBytes(    response.body!,     getLines(        getMessages(id =&gt; &#123;            if (id) &#123;                // store the id and send it back on the next retry:                headers[LastEventId] = id;            &#125; else &#123;                // don't send the last-event-id header anymore:                delete headers[LastEventId];            &#125;        &#125;,         retry =&gt; &#123;            retryInterval = retry;        &#125;,         onmessage    )));\n\ngetBytes这个方法非常的简单，仅仅是读取后端返回的流，并调用onChunk回调函数，将流中的数据传递给onChunk，这个onChunk就是getLines返回的方法\n/** * Converts a ReadableStream into a callback pattern. * @param stream The input ReadableStream. * @param onChunk A function that will be called on each new byte chunk in the stream. * @returns &#123;Promise&lt;void&gt;&#125; A promise that will be resolved when the stream closes. */export async function getBytes(stream: ReadableStream&lt;Uint8Array&gt;, onChunk: (arr: Uint8Array) =&gt; void) &#123;    const reader = stream.getReader();    let result: ReadableStreamDefaultReadResult&lt;Uint8Array&gt;;    while (!(result = await reader.read()).done) &#123;        onChunk(result.value);    &#125;&#125;\n\ngetLines源码如下：\n/**  * 将任意字节块解析为 EventSource 行缓冲区。 * 每行应为 \"field: value\" 格式，并以 \\r、\\n 或 \\r\\n 结尾。 * @param onLine 每次遇到新行时调用的函数。 * @returns 一个应该为每个传入字节块调用的函数。 */export function getLines(onLine: (line: Uint8Array, fieldLength: number) =&gt; void) &#123;    let buffer: Uint8Array | undefined;    let position: number; // 当前读取位置    let fieldLength: number; // 行的字段长度    let discardTrailingNewline = false;    // 返回一个可以处理每个传入字节块的函数：    return function onChunk(arr: Uint8Array) &#123;        if (buffer === undefined) &#123;            buffer = arr;            position = 0;            fieldLength = -1;        &#125; else &#123;            // 我们还在解析旧行。将新字节附加到缓冲区：            buffer = concat(buffer, arr);        &#125;        const bufLength = buffer.length;        let lineStart = 0; // 当前行的起始位置        while (position &lt; bufLength) &#123;            if (discardTrailingNewline) &#123;                if (buffer[position] === ControlChars.NewLine) &#123;                    lineStart = ++position; // 跳到下一个字符                &#125;                                discardTrailingNewline = false;            &#125;                        // 向前查找直到行结束:            let lineEnd = -1; // 行结束符的位置            for (; position &lt; bufLength &amp;&amp; lineEnd === -1; ++position) &#123;                switch (buffer[position]) &#123;                    case ControlChars.Colon:                        if (fieldLength === -1) &#123; // 第一个冒号                            fieldLength = position - lineStart;                        &#125;                        break;                    // @ts-ignore:7029 \\r case below should fallthrough to \\n:                    case ControlChars.CarriageReturn:                        discardTrailingNewline = true;                    case ControlChars.NewLine:                        lineEnd = position;                        break;                &#125;            &#125;            if (lineEnd === -1) &#123;                // 我们到达了缓冲区的末尾，但行还没有结束。                // 等待下一个 arr 并继续解析：                break;            &#125;            // 我们到达了行结束，发送出去：            onLine(buffer.subarray(lineStart, lineEnd), fieldLength);            lineStart = position; // 我们现在在下一行            fieldLength = -1;        &#125;        if (lineStart === bufLength) &#123;            buffer = undefined; // 我们读完了        &#125; else if (lineStart !== 0) &#123;            // 创建一个从 lineStart 开始的新视图到 buffer，这样我们就不需要在新 arr 时复制前面的行：            buffer = buffer.subarray(lineStart);            position -= lineStart;        &#125;    &#125;&#125;\n\n这是一个行缓冲解析器。\n行缓冲解析器：\n行缓冲解析器是一种用于处理流式数据的解析器，它将输入数据分割成行，并提供回调函数来处理每一行（onLine方法）。\nonLine前面一大段代码就是一个滑动窗口，当遇到\\r\\n时，会调用onLine方法，将窗口内的数据传递给onLine方法。onLine方法是下面的getMessages方法返回的方法，这里借用了闭包存储每一行的数据\ngetMessages源码如下：\n/**  * 将行缓冲区解析为 EventSourceMessages。 * @param onId 每次遇到 `id` 字段时调用的函数。 * @param onRetry 每次遇到 `retry` 字段时调用的函数。 * @param onMessage 每次遇到消息时调用的函数。 * @returns 一个应该为每个传入行缓冲区调用的函数。 */export function getMessages(    onId: (id: string) =&gt; void,    onRetry: (retry: number) =&gt; void,    onMessage?: (msg: EventSourceMessage) =&gt; void) &#123;    let message = newMessage();    const decoder = new TextDecoder();    // 返回一个可以处理每个传入行缓冲区的函数：    return function onLine(line: Uint8Array, fieldLength: number) &#123;        if (line.length === 0) &#123;            // 空行表示消息结束。触发回调并开始新消息：            onMessage?.(message);            message = newMessage();        &#125; else if (fieldLength &gt; 0) &#123; // 排除注释和没有值的行            // line is of format \"&lt;field&gt;:&lt;value&gt;\" or \"&lt;field&gt;: &lt;value&gt;\"            // https://html.spec.whatwg.org/multipage/server-sent-events.html#event-stream-interpretation            const field = decoder.decode(line.subarray(0, fieldLength));            const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);            const value = decoder.decode(line.subarray(valueOffset));            switch (field) &#123;                case 'data':                    // 如果此消息已经有数据，则将新值附加到旧值。                    // 否则，只需设置为新值：                    message.data = message.data                        ? message.data + '\\n' + value                        : value; // 否则，只需设置为新值：                    break;                case 'event':                    message.event = value;                    break;                case 'id':                    onId(message.id = value);                    break;                case 'retry':                    const retry = parseInt(value, 10);                    if (!isNaN(retry)) &#123; // 根据规范，忽略非整数                        onRetry(message.retry = retry);                    &#125;                    break;            &#125;        &#125;    &#125;&#125;\n这个方法的逻辑是：\n\n创建一个message对象，用于存储每一行的数据\n\n创建一个decoder对象，用于解码line中的数据\n\n返回一个onLine方法，用于处理每一行的数据\n\n在onLine方法中，会根据field的值，将数据存储到message对象中\n\n当遇到\\r\\n时，会调用onMessage方法，将message对象传递给onMessage方法\n\n\ndata: 第一行数据data: 第二行数据此时会走 message.data + '\\n' + value最终message.data = '第一行数据\\n第二行数据'\n\n总结本文详细介绍了在AI大模型开发中处理数据流的重要工具 @microsoft/fetch-event-source。主要包含以下几个要点：\n\nSSE(Server-Sent Events)是一种服务器向浏览器发送实时数据的单向通信机制。\n\n传统的EventSource对象虽然能处理SSE，但仅支持GET请求且不支持自定义头部，限制了其实际应用场景。\n\n@microsoft/fetch-event-source提供了更灵活的解决方案：\n\n支持POST请求和自定义头部\n允许建立持久连接\n支持双向数据流通信\n\n\n在实际使用中需要注意几个关键点：\n\n后端返回的数据流格式需要严格遵循&lt;field&gt;:&lt;value&gt;的格式\n处理多行文本时需要特别注意换行符的处理\n建议使用封装好的通用处理方法来简化开发\n\n\n源码层面，该库通过getBytes、getLines和getMessages三层处理机制，实现了对SSE数据流的完整解析和处理。\n\n\n这个工具为AI大模型应用开发提供了可靠的数据流处理方案，特别适合类似ChatGPT这样需要流式响应的应用场景。\n","categories":["AI"],"tags":["AI"]},{"title":"ErrorBoundary预防白屏","url":"/2022/04/01/ErrorBoundary%E9%A2%84%E9%98%B2%E7%99%BD%E5%B1%8F/","content":"设计动机白屏场景：\n前端边缘场景导致的代码错误\n沟通没有对称，后端数据结构的突变导致代码层报错\n后端部署服务导致的接口不可用进而产生的前端报错\n\n解决方案：为了提升用户体验上的友好，增加ErrorBoundary做UI层降级当页面发生报错的时候，用户依然可以点击菜单栏进行模块切换，无需刷新页面或者重新打开路由，防止客户暴躁的情况出现\n具体实现：\n增加ErrorBoundary组件，用于捕获错误，将其包裹在渲染非导航栏渲染位置\n记录报错路由，当用户重新点击其他模块时与错误路由比较，如果不一致，取消错误，重新请求页面\n渲染遇到错误时对应需要展示的组件\n\n\n\nErrorBoundaryErrorBoundary.jsx\nclass ErrorBoundary extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123; hasError: false, pathname: props.location.pathname &#125;;  &#125;    static getDerivedStateFromError() &#123;    // 更新 state 使下一次渲染能够显示降级后的 UI    return &#123; hasError: true &#125;;  &#125;    componentDidUpdate(nextProps, nextState) &#123;    // 如果路由不相等, 并且是之前有错误的, 取消错误, 重新展示正常的页面    if (nextProps.history.location.pathname !== nextState.pathname &amp;&amp; this.state.hasError) &#123;      // eslint-disable-next-line react/no-did-update-set-state      this.setState(&#123;        hasError: false,      &#125;);    &#125;  &#125;      componentDidCatch(error) &#123;    this.setState(&#123;      pathname: this.props.location.pathname, // 设置对应的错误路由    &#125;);    console.log(error);    // 你同样可以将错误日志上报给服务器    // logErrorToMyService(error, errorInfo);  &#125;    render() &#123;    if (this.state.hasError) &#123;      // 你可以自定义降级后的 UI 并渲染      return &lt;ErrorUI /&gt;;    &#125;        return this.props.children;  &#125;&#125;export default withRouter(ErrorBoundary);\n\n注意点：\n\ncomponentDidUpdate中获取最新路由的时候需要从nextProps中路由对象history中获取，而非location，location获取到的并非最新的路由，而且跳转前当前的路由\ncomponentDidCatch用户捕获错误，方法可以返回error，可以在其进行错误上报，未来可扩展\n\nLayout.jsx\n&lt;Layout&gt;  // 顶部导航  &lt;Navigation    collapsed=&#123;collapsed&#125;    customExtraItem=&#123;customExtraItem&#125;    customNavigation=&#123;customNavigation&#125;    logo=&#123;logo&#125;    pathArr=&#123;pathArr&#125;    toggleCollapsed=&#123;toggleCollapsed&#125;    &#123;...navigation&#125;    /&gt;  &lt;Layout className=&#123;styles['section']&#125;&gt;    // 侧边导航    &#123;      !noSider &amp;&amp;        &lt;SideMenu          collapsed=&#123;collapsed&#125;          customSideMenu=&#123;customSideMenu&#125;          customSideMenuItem=&#123;customSideMenuItem&#125;          getBadgeCount=&#123;getBadgeCount&#125;          keyMap=&#123;keyMap&#125;          menu=&#123;menu&#125;          pathArr=&#123;pathArr&#125;          toggleCollapsed=&#123;toggleCollapsed&#125;          /&gt;    &#125;    // 主体内容    &lt;div className=&#123;styles['content']&#125;&gt;      // 错误边界包裹位置      &lt;ErrorBoundary&gt;        &#123;children&#125;      &lt;/ErrorBoundary&gt;    &lt;/div&gt;  &lt;/Layout&gt;&lt;/Layout&gt;\n\n效果展示\n","categories":["业务"],"tags":["业务","前端"]},{"title":"HTTP(持续更新)","url":"/2021/09/13/HTTP/","content":"HTTP相关报文结构起始行 + 头部 + 空行 +实体\n头部格式特点：\n\n不区分大小写\n字段名不允许出现空格, 不允许出现_\n字段名后面需要紧接着:请求方法\n\nGET 和 POST 有什么区别？\n缓存：GET请求的数据会被浏览器缓存，POST不会\n编码：GET只能接受ASCII码，POST没有限制\n幂等性：GET请求是幂等的，无论多少次，结果是一样的，POST可能会随着次数的不同而不同\n参数：GET参数都是放在URL中的，POST是放在body中的\nTCP: GET的话是作为一个包发出去的，POST会分成两个包，首先发head,然后发body\n\nURI\n组成格式：协议名 + 主机信息 + 主机名:端口 + 资源路径 + 参数 + 锚点\n状态码1xx: 中间状态，还有后续操作\n\nHTTP升级为webSocket，同意变更返回101\n\n2xx: 成功状态\n\n200 最常见的成功\n204 和200一样，响应头后没有body\n206 部分内容，断点续传，需要带上响应头字段Content-Range\n\n3xx: 原资源位置变动，重定向\n\n301 永久重定向(例如：HTTP变更为HTTPS)\n302 临时重定向(例如：服务器升级)\n304 协商缓存命中\n\n4xx: 客户端请求有误\n\n400 Bad Request\n403 Forbidden 服务端禁止\n404 资源没找到\n405 请求方法有误\n413 请求体数据过大\n414 请求行URI过大\n\n5xx: 服务端有误\n\n500 服务器内部错误\n501 客户端请求功能不支持\n502 服务端是正常的，但是访问出错(运维比较多)优缺点\n\n优点\n灵活可扩展\n\n\n请求易扩展，保证格式的情况下自定义请求头，请求实体等\n传输多样，可以传输文本，照片，视频等等\n\n\n基于TCP可靠传输\n\n请求——应答模式\n\n无状态，独立无关，不需要保存信息，节省网络开销\n\n\n缺点\n无状态，需要大量获取重复信息\n\n明文传输，易被攻击\n\n\nAccept系列字段数据格式发送端发送的数据类型用Content-Type\n想要接收的数据类型用Accept\n压缩方式接收的压缩方式字段Accept-Encoding，值为常见的压缩方式gzip deflate br\n支持语言接收的语言类型Accept-Language\n字符集发送端表现在Content-Type, 接收端表现在Accept-Charset\n定长与不定长数据定长Content-Length字段，只能比响应的短，不能比响应结果长(会导致传输失败)\n不定长Transfer-Encoding: chunked配合Content-Length进行分段传输，后端会将内容分段传输过来，其中Connection保持keep-alive\n大文件传输Accept-Ranges范围传输\nRange 字段拆解# 单段数据Range: bytes=0-9# 多段数据Range: bytes=0-9, 20-39\n\n多段数据返回HTTP/1.1 206 Partial ContentContent-Type: multipart/byteranges; boundary=00000010101Content-Length: 189Connection: keep-aliveAccept-Ranges: bytes--00000010101Content-Type: text/plainContent-Range: bytes 0-9/96i am xxxxx--00000010101Content-Type: text/plainContent-Range: bytes 20-29/96eex jspy e--00000010101--\n\n其中Content-Type: multipart/byteranges;boundary=00000010101表示多段数据返回，boundary表示多段数据的分割符\n表单数据主要通过Content-Type决定表单数据的格式\napplication/x-www-form-urlencoded会编码成&amp;分隔的键值对, 以URL的方式编码\nmultipart/form-data请求头包含boundary，浏览器决定。每一个表单元素都是独立的资源表述\n队头阻塞概念和原因同一个TCP长连接，队首请求阻塞导致后面的请求没有正常执行\n解决方案\n域名分片，使用多个二级域名减轻http的压力\n1.x版本使用并发连接，一次可以连接6个http请求(chrome)\nHTTP/2使用了多路复用，采用二进制分帧，将头部信息和实体数据分别采用二进制形式传输，同一个连接的请求是有序的。Cookie\n\nCookie是保存会话状态的方式，服务端可用Set-Cookie来对客户端写入\n生存周期Expire: 存放过期时间\nMax-Age: 单位是秒，存放可保存的时间\n作用范围Domain: 只在当前域名下生效\nPath: 当前域名的指定路径下生效\n安全相关Secure: 只能通过HTTPS来传输Cookie\nSameSite: Strict表示只有同源才能传输，Lax只有get请求才能传输，None没有限制\nHttpOnly: 只能传输，不能通过js访问，可以预防XSS攻击\n代理正向代理代理客户端，服务器不知道发起请求的是哪个客户端(例如：VPN)\n反向代理代理服务端，客户端不知道响应请求的是哪个服务器(例如：负载均衡)\nVia字段服务端收到的请求头上会带有\nvia: proxy-server1 proxy-server2\n\n客户端收到的响应头上会带有\nvia: proxy-server2 proxy-server1\n\n缓存具体看浏览器八股文\n强缓存\nExpire字段设置请求时间并发送给服务器，服务器根据此字段给出的时间决定返回内容\nCache-Control + max-age控制，private表示不允许代理服务器缓存。public表示允许代理服务器缓存，max-age表示缓存时间\n\n协商缓存\nif-modified-since和last-modified，根据文件最后修改时间判断是否是缓存中拿，缺陷就是修改文件可能前后一致，但是时间不一致，或者说本地时间和服务器时间可能有偏差，缓存都会失效，因此也有可能会采用下面2的形式。\nif-none-match和Etag，根据文件内容生成hash来确定，缺点就是消耗服务器资源，并且不同的服务器生成的hash也可能不一样。跨域问题\n\n协议+主机+端口三者有一个不一致称为跨域\n通常请求是由浏览器渲染进程创建的，网络进程发起的，拦截是由主进程拦截的，这里涉及到了进程的通信，利用Unix Domain Socket套接字，配合事件驱动的高性能网络并发库libevent完成进程的 IPC 过程\nCORS(跨域资源共享)服务端Access-Control-Allow-Origin确认了允许跨域的源服务端Access-Control-Allow-Credentials确认了Cookie是否允许跨域，同时客户端withCredentials = true保证了可以跨域\n非简单请求的跨域非简单请求会发预检请求，预检请求会拿到一系列Access-Control-xxx的字段，浏览器主进程会根据这些字段进行拦截\nJSONP利用script标签没有跨域限制，缺点是只能发get请求\n实现方式\nconst jsonp = (&#123; url, params, callbackName &#125;) =&gt; &#123;    const generateUrl = () =&gt; &#123;        let requestUrl = '';        let callbackName = callbackName || Math.random().toString().replace(',', '');        for(var key in params)&#123;            requestUrl += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;`        &#125;        requestUrl += `$&#123;callback&#125;=$&#123;callbackName&#125;`        return `$&#123;url&#125;?$&#123;requestUrl&#125;`    &#125;    return new Promise((resolve, reject) =&gt; &#123;        const scriptEle = document.createElement('sctipt')        scriptEle.src = generateUrl();        document.body.appendChild(scriptEle);        window[callbackName] = (data) =&gt; &#123;            resolve(data);            document.body.removeChild(scriptEle)        &#125;    &#125;)&#125;\nTLS握手流程\n客户端生成随机数client_random、加密方式、TLS版本传给服务端\n服务端生成server_random、拿到数字证书传给客户端\n客户端验证数字证书，并用 数字证书的公钥加密会话的密钥(对称加密的密钥) 传给后端\n后端用数字证书的私钥对密钥进行解密，拿这个密钥进行对称加密沟通\n\n断开重连Session ID每个服务器针对每次会话都有一个id，但是不同服务器id可能不一样。\nSession ticket服务器加密完成之后返给客户端的，发到其他服务器上的时候就可以根据这个ticket获取信息。\nHTTP2多路复用采用二进制分帧，解决了队头阻塞的问题。\n二进制分帧，将数据转换为二级制，保存在头部和实体中，通过流ID来保证请求的一致性，并且可以是双向的\n头部压缩头部压缩，减少网络传输数据量\n","categories":["计算机网络"],"tags":["计算机网络","HTTP"]},{"title":"Js八股文(持续更新)","url":"/2022/06/10/Js%E5%85%AB%E8%82%A1%E6%96%87/","content":"只针对自己不太熟或者面试常问的有针对性的整理\n数据类型和检测方式SymbolSymbol是ES6新出的数据结构\n定义：Symbol(&quot;key&quot;)\n特点： 每次Symbol(&#39;key&#39;)都会生成一个唯一的值\n获取：Symbol.for(&#39;key&#39;)，会先检查给定的key是否已经存在，如果不存在才会新建一个值\nlet s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // true\n\ntypeoftypeof注意点：只能检测原始类型(除了null)，不能检测引用类型(均为&quot;object&quot;)原因：null比较特殊，为000000, 对象存在在计算机中，都是以000开始的二进制存储，所以检测出来的结果是对象\ntypeof null === \"object\"\n\ninstanceofa instanceof b就是在a原型链上找是否有b的原型，找到位true, 否则为false\n手写instanceoffunction myInstanceof(left, right)&#123;    let node = left.__proto__    let protoType = right.protoType    while(node)&#123;        if(node === protoType)&#123;            return true        &#125;        node = node.__proto__    &#125;    return false&#125;\n\n数据转换对象转换规则\n调用[[Symbol.toPrimitive]]\n调用valueOf()\n调用toString()\n\n如果都没有返回基础类型，会报错。\n隐式类型转换(==)个人总结规则：\n\n同类型不转换\n不同类型，一方为string/number, 另一方试图转换为number, 如果是对象，那么遵守上面的对象转换规则\n如果一方是null/undefined, 另一方必须是null/undefined, 否则为false\n\nvar a = &#123;  value: 0,  valueOf: function() &#123;    this.value++;    return this.value;  &#125;&#125;;// 注意这里a又可以等于1、2、3console.log(a == 1 &amp;&amp; a == 2 &amp;&amp; a ==3);  //true 连续调用规则二 Object隐式转换\n\nthis指针指向问题\n谁调用它，this指向谁\n\n箭头函数的this指向箭头函数上层第一个普通函数的this\n\nnew关键字调用的构造函数的this始终指向创建出来的实例\n\napply, bind, call可以改变this指针的指向，指向传递进去的第一个对象。注意：构造函数无法修改指针指向\n\n\nnew相关new关键字执行以下几个步骤\n\n以构造函数的原型作为原型创建一个对象\n\n将构造函数内部的this指向创建出来的对象，并调用构造函数\n\n如果有返回值并且返回值为对象，那么返回， 否则将新创建出来的实例对象返回\n\n\n手写bind和apply// bind原理function bind(context, ...rest)&#123;    // 没传就正常返回函数好了    if(context === undefined) return this;     if(!(context instanceof Object)) return &#123;        throw new Error(\"上下文必须是对象\")    &#125;    const _this = this;    return F()&#123;        // 由于new出来的this指向的都是这个实例，实例 instanceof F为 true        if(this instanceof F)&#123; // 如果是构造函数            return new _this(...rest)        &#125;        return F.apply(context, rest)    &#125;&#125;// apply原理function apply(context, ...rest)&#123;    let fn = this;    const symbol = Symbol(\"fn\") // 避免重复    context[symbol] = fn    const res = context.fn(...rest); // 保证this指向context    delete context[symbol]    return res&#125;\n\n作用域相关ES5有全局作用域和函数作用域，ES6新增块级作用域\n这里要注意let,const,var，暂时性死区、变量提升相关，不再赘述\n上下文\n编译阶段上下文已经形成\n\n上下文中包括变量对象VO、作用域链、this指针的指向\n\n作用域链保存在作用域[[Scopes]]属性中，即全局作用域就挂在window对象上，函数作用域保存在函数对象上\n\n\n闭包定义：外部函数能够访问内部函数定义的变量\n本质：当前环境存在指向父级作用域的引用(全局作用域就是本身)\n这里分类讨论：\n\n在函数作用域下的闭包\n\nfunction a()&#123;    var x = 1    function b()&#123;        console.log(x)    &#125;    return b&#125;var f = a()console.dir(f)/** f函数上的[[Scopes]]如下 [     Closure:&#123;         x: 1     &#125;,     Global:&#123;         ...window相关变量     &#125; ] * /\n\n\n在全局作用域下的闭包\n\n\n注意：可能有些人以为以下不是闭包，问题在于如下当前环境是否有指向父级作用域的变量(有！全局作用域的父级是本身)因此他是闭包\n\nvar x = 1function b()&#123;    console.log(x)&#125;console.dir(b)/** f函数上的[[Scopes]]如下 [     Global:&#123;          x: 1,         ...window相关变量     &#125; ] * /\n\n补充说明全局作用域下let const定义的变量比较特殊，在[[Scopes]]上的表现和其他不太一样，会单独定义一个对象Script, 存在那个上面\nlet a = 1;function fn()&#123;    console.log(a)&#125;/* fn的[[Scopes]]如下[    Script: &#123;        a: 1    &#125;,    Global:&#123;        fn,        ...其他window对象    &#125;]*/\n\n原型和原型链一张图解释\n\n模块化CommonJSrequire导入，module.exports导出\nmodule.exports指向exports\n导出的都是值拷贝, 即导出后，导入值改变不会影响已经导出的值\nimport和exportimport 导入 export 导出\n需要babel转换\n导出的都是引用拷贝, 即导出后，导入值改变会影响已经导出的值\nCMD和AMDCMD和AMD用的比较少了，两者都是用来解决异步加载的问题区别在于：\n\nCMD是就近依赖，AMD是依赖前置\n依赖模块的执行实际，AMD已下载就执行(即&#39;./a&#39;, &#39;./b&#39;), CMD是需要的时候再执行。// CMDdefine(function(require, exports, module) &#123;  var a = require(\"./a\");  a.doSomething();  // 此处略去 100 行  var b = require(\"./b\"); // 依赖可以就近书写  b.doSomething();  // ...&#125;);// AMD 默认推荐define([\"./a\", \"./b\"], function(a, b) &#123;  // 依赖必须一开始就写好  a.doSomething();  // 此处略去 100 行  b.doSomething();  // ...&#125;)\n\n\n\nconst isComplexStruct = obj =&gt; (typeof obj === 'object' || typeof obj === 'function') &amp;&amp; obj !== nullvar deepClone = (obj, hash = new WeakMap()) =&gt; &#123;    if(obj.constructor === Date)&#123;        return new Date(obj)    &#125;    if(obj.constructor === RegExp)&#123;        return new RegExp(obj)    &#125;    if(hash.has(obj))&#123;        return hash.get(obj)    &#125;    // 获取描述符    const allDes = Object.getOwnPropertyDescriptors(obj)    const cloneObj = Object.create(Object.getPrototypeOf(obj), allDes)    hash.set(obj, cloneObj)    for(var key of Reflect.ownkeys(ownKeys))&#123;        cloneObj[key] = isComplexStruct(obj) ? deepClone(obj[key], hash) : obj[key]    &#125;    return cloneObj;&#125;\n\nfunction debounce(fn, wait)&#123;    var timer = null;    return (...rest) =&gt; &#123;        if(timer)&#123;            clearTimeout(timer)            timer = null        &#125;        timer = setTimeout(() =&gt; &#123;            fn(...rest)        &#125;, wait);    &#125;&#125;function throttle(fn, delay)&#123;    var preTime = Date.now()    return (...rest) =&gt; &#123;        var nowTime = Date.now()        if(nowTime - preTime &gt;= delay)&#123;            preTime = Date.now()            return fn(...rest)        &#125;    &#125;&#125;\n\nIterator本质上是个接口，只要部署了Symbol.iterator的数据结构都是被认为是可遍历的，遍历的时候反复调用next方法\n这个接口需要返回一个对象，如下：\n&#123;    next()&#123;        return &#123;            value: xxx,            done: false,        &#125;    &#125;&#125;\n\nPromise\n解决异步编程的痛点(回调地狱)\n\n一旦状态改变了就不会改回来\n\nPromise调用是同步的，.then是异步的, 个人理解是创建.then返回的Promise状态这个过程是异步的\n\n\n\n手写Promise以下写一个简易版本, 注意点如下:\n\nPromise本身是同步的, 传入的函数需要同步调用\n\nresolveCallback, rejectCallback的回调数组是为了处理异步情况\n\n\n\nclass MyPromise&#123;    constructor(fn)&#123;        this.value = null;        this.reason = null;        this.status = 'pending'        this.onResolve = this.onResolve.bind(this);        this.onReject = this.onReject.bind(this);        this.resolveCallback = [];        this.rejectCallback = [];        fn(this.onResolve, this.onReject)    &#125;    onResolve(val)&#123;        if(this.pending === 'pending')&#123;            this.pending = 'fulfilled'            this.value = val        &#125;        while(this.resolveCallback.length)&#123;            this.resolveCallback.shift()(this.value)        &#125;    &#125;    onReject(reason)&#123;        if(this.pending === 'pending')&#123;            this.pending = 'reject'            this.reason = reason        &#125;         while(this.rejectCallback.length)&#123;            this.rejectCallback.shift()(this.reason)        &#125;    &#125;&#125;MyPromise.protoType.then = (onResolve, onReject) =&gt; &#123;    return new MyPromise(() =&gt; &#123;        if(this.pending === 'fulfilled')&#123;            // 这里处理开启微任务，等待返回的promise创建完成            // queueMicrotask(() =&gt; &#123; // 这里暂时不展开了                onResolve(this.value)            // &#125;)        &#125;        if(this.pending === 'reject')&#123;            onReject(this.reason)        &#125;        if(this.pending === 'pending')&#123;            this.resolveCallback.push(onResolve)            this.rejectCallback.push(onReject)        &#125;    &#125;)&#125;\n\nasync/await可以认为是Promise的语法糖，也可以认为是Generator的语法糖\n注意点：\n\n没法处理并发的过程(需要Promise.all)\n\n注意以下代码\n\n\na = a + 10这个a尤其要注意b调用的时候是0，而不是1，只有遇到await才会开启协程与主线程合作。\nvar a = 0var b = async () =&gt; &#123;  a = a + await 10  console.log('2', a) // -&gt; '2' 10  a = (await 10) + a  console.log('3', a) // -&gt; '3' 20&#125;b()a++console.log('1', a) // -&gt; '1' 1\n\n事件循环以下不区分node环境还是浏览器环境\n微任务：Promise.then MutationObserver process.nextTick Object.observe\n宏任务队列：setTimeout setInterval 读写I/O setImmediate UI渲染\njs线程与GUI互斥，可以使用requestAnimationFrame把这两件事情给关联起来, 这个 API 保证在下次浏览器渲染之前一定会被调用, 这个是浏览器自己去调节的\n浏览器的事件循环主线程 -&gt; 推入事件表, 注册回调函数（Event Table） -&gt; 主线程执行完毕 -&gt; 微任务队列 -&gt; GUI渲染 -&gt; 宏任务队列(满足条件的执行回调) -&gt; 宏任务对应的微任务\nnode的事件循环\n以上各阶段注意点：\n\ntimer阶段处理setTimeout setInterval等宏任务\n\npoll阶段处理读写I/O\n\ncheck阶段处理setImmediate\n\nsetTimeout(() =&gt; { console.log(&#39;setTimeout&#39;);}, 0);和setImmediate到底谁先执行\n\n设置为0， 默认为1ms\n如果进入eventLoop都不到1ms, 那么触发了回调的条件，优先执行setTimeout，否则执行setImmediate\n\n\n\n深浅拷贝手写深拷贝注意以下几点：\n\nDate对象\n正则对象\n循环引用\n原型的拷贝\nSymbol关键字\n函数\n原对象的描述符（可枚举，可写性等等）\n\nfunction isComplexStruct(obj)&#123;    return (typeof obj === 'object' || typeof obj === 'function') &amp;&amp; obj !== null&#125;function cloneDeep(obj, hashMap = new WeakMap)&#123;    if(obj.constructor === Date)&#123;        return new Date(obj)    &#125;    if(obj.constructor === RegExp)&#123;        return new RegExp(obj)    &#125;    if(hashMap.has(obj))&#123;        return hashMap.get(obj)    &#125;    const allDes = Object.getOwnPropertyDescriptors(obj)    const cloneObj = Object.create(Object.getPrototypeOf(obj), allDes)    hashMap.set(obj, cloneObj)    for(var key of Reflect.ownKeys(obj))&#123;        cloneObj[key] = (isComplexStruct(obj[key]) &amp;&amp; typeof obj[key] !== 'function') ? cloneDeep(obj[key], hashMap) : obj[key]    &#125;    return cloneObj&#125;\n\n防抖和节流防抖：事件触发n秒后再执行回调函数，如果期间又被触发，那么重新计时\n节流：在特定的时间段只执行一次\n手写防抖注意点：清空已有的定时器\nfunction debounce(fn, wait)&#123;    var timer = null;    return (...rest) =&gt; &#123;        if(timer)&#123;            clearTimeout(timer);            timer = null;        &#125;        timer = setTimeout(() =&gt; &#123;           return fn(...rest)        &#125;, wait);    &#125;&#125;\n\n手写节流注意点：用当前时间作为依据，判断是否在指定的时间区间内\nfunction throttle(fn, delay) &#123;    var preTime = Date.now()    return (...rest) =&gt; &#123;        if(Date.now() - preTime &gt;= delay)&#123;            preTime = Date.now()            return fn(...rest)        &#125;    &#125;&#125;\n\n数组相关数组比较熟悉，主要有个常用的排序算法\n快排思想：抽一个中间值，遍历数组，大的放右边，小的放左边，递归左右数组排序在合并\nvar quickSort = (array) =&gt; &#123;    var quick = (arr) =&gt; &#123;        if(arr.length &lt;= 1) return arr;        const index = arr.length &gt;&gt; 1;        const middleVal = arr.splice(index, 1);        const left = [];        const right = [];        for(var i = 0; i &lt; arr.length; i++)&#123;            if(arr[i] &lt;= middle)&#123;                left.push(arr[i])            &#125;            if(arr[i] &gt; middle)&#123;                right.push(arr[i])            &#125;        &#125;        return quick(left).concat([middle], quick(right))    &#125;    return quick(array)&#125;\n\n柯里化柯里化就是将一系列参数转换为一个或者多个参数，多次调用\nvar curry = function(fn, ...args)&#123;    const length = fn.length    return function(...rest)&#123;        const realLength = args.length + rest.length        if(realLength &lt; length)&#123;            return curry.call(this, fn, ...[...args, ...rest])        &#125;        else&#123;            return fn.apply(this, [...args, ...rest])        &#125;    &#125;&#125;","categories":["面试"],"tags":["面试"]},{"title":"React-commit阶段","url":"/2022/06/24/React-commit%E9%98%B6%E6%AE%B5/","content":"React-commit阶段React-render阶段，当组件发生更新的时候，beginWork先为更新的组件打上了flag，\nTodo\n","categories":["React"],"tags":["前端","React","源码系列"]},{"title":"React运行时","url":"/2020/08/02/React-UI-render/","content":"\nDan在OverReact上发表的文章深入浅出，本文只针对个人之前不理解的点进行思考，采用了他的案例，参考了他的文章——将 React 作为 UI 运行时。\n\n\n再写UI运行时的时候,发现一切都离不开Fiber,这里参考了掘金博主武器大师1024的一篇文章,并补充了一些他的案例React Fiber,同时,此案例也是Lin Clark presentation in ReactConf 2017演讲上的一篇案例。\n\n大多数人关注React，关注它的使用方法，关注它创建页面的逻辑和效果，而忽略其模型和React本质上的一些东西，到底React帮我们做了什么?\n\n\n\n宿主树和宿主实例\n什么是宿主树，什么是宿主实例？这是一个概念上的问题，区别两者，其实很简单，就像整体和局部的关系。例如一个Dom树，就是一个宿主树，Dom树中的一个div，就是一个宿主实例。\n宿主实例有自己的属性和方法，我们可以操作宿主方法做一些想做的事情，例如appendChild，setAttribute等等\nReact又是怎么利用宿主树和宿主实例的呢？在我看来，React的宿主树，是由其宿主实例构成的，而React的宿主实例，就是React元素，React元素是一个对象，与DOM树横向比对，大同小异，所以React再做UI渲染时，可以轻松的将其映射为对应的DOM元素，React经常帮我们做的，就是这个。\nReact解放了我们直接操作宿主树和宿主实例，因为React帮我们做了这个事情。做这些事情的同时，React又保证了另外两个事情:\n\n稳定性: 宿主树的稳定性\n通用性：宿主树中的宿主实例单独抽出来，依旧不会改变其UI结构，达到可复用的状态\n\nReact操作宿主树和DOM有什么不同？\nDOM会导致突变，直接操作宿主实例。在之后往里面增加或者删除子节点。宿主实例是完全可变的。\nReact是通过克隆双亲树并始终替换掉顶级子树的宿主环境。\n\nReact的宿主实例——React元素\nReact的元素不是永远存在的，他总是在重建和删除之间循环\n你不能直接操作React元素(与DOM不同)，如果想改变，从头开始渲染\n\nReact渲染\nReactDOM.render初次调用看以下一段代码\nReactDOM.render(  // &#123; type: 'button', props: &#123; className: 'blue' &#125; &#125;  &lt;button className=\"blue\" /&gt;,  document.getElementById('container'));\n\n\n初始调用时，实际操作就是把你的宿主树转换成实际的dom树渲染\n\n// 在 ReactDOM 渲染器内部（简化版）function createHostInstance(reactElement) &#123;  let domNode = document.createElement(reactElement.type); // 这里是button  domNode.className = reactElement.props.className; // 这里是blue  return domNode;&#125;// 然后将其放进domdomContainer.appendChild(domNode);\n\n再次调用会如何做\n想必看过React文档的都知道，会进行比对，只对需要更新的一部分进行更新，下面贴了Dan文章里的两段代码，简述了React的过程。但实际比对算法要复杂的多\n\nReactDOM.render(  &lt;button className=\"blue\" /&gt;,  document.getElementById('container'));// ... 之后 ...// 应该替换掉 button 宿主实例吗？// 还是在已有的 button 上更新属性？ReactDOM.render(  &lt;button className=\"red\" /&gt;,  document.getElementById('container'));\n\n\nReact工作流程大致如下\n\n// let domNode = document.createElement('button');// domNode.className = 'blue';// domContainer.appendChild(domNode);ReactDOM.render(  &lt;button className=\"blue\" /&gt;,  document.getElementById('container'));// 能重用宿主实例吗？能！(button → button)// domNode.className = 'red';ReactDOM.render(  &lt;button className=\"red\" /&gt;,  document.getElementById('container'));// 能重用宿主实例吗？不能！(button → p)// domContainer.removeChild(domNode);// domNode = document.createElement('p');// domNode.textContent = 'Hello';// domContainer.appendChild(domNode);ReactDOM.render(  &lt;p&gt;Hello&lt;/p&gt;,  document.getElementById('container'));// 能重用宿主实例吗？能！(p → p)// domNode.textContent = 'Goodbye';ReactDOM.render(  &lt;p&gt;Goodbye&lt;/p&gt;,  document.getElementById('container'));\n\n这里有个小注意点需要注意一下，当遇到条件语句时，React并不会重新创建元素，这依赖于元素的顺序，例如：这里的input始终在第二个\nfunction Form(&#123; showMessage &#125;) &#123;  let message = null;  if (showMessage) &#123;    message = &#123;      type: 'p',      props: &#123; children: 'I was just added here!' &#125;    &#125;;  &#125;  return &#123;    type: 'dialog',    props: &#123;      children: [        message,        &#123; type: 'input', props: &#123;&#125; &#125;      ]    &#125;  &#125;;&#125;\n\n由上面的小注意点引申出，当遇到列表时，React会去比对元素，如果元素相同，那么直接复用。问题是，当我们遇到类似于商品列表时，商品列表往往各项都不相同，或者说一个列表中有几项相同，那么React该怎么办，如果还是按照顺序来，那每个元素都将被更新。\n这样导致的问题是，每个元素更新，消耗性能。同时，React会把类似于input这样的组件当时的值一并复用过来，导致潜在的bug。\nfunction ShoppingList(&#123; list &#125;) &#123;  return (    &lt;form&gt;      &#123;list.map(item =&gt; (        &lt;p&gt;          You bought &#123;item.name&#125;          &lt;br /&gt;          Enter how many do you want: &lt;input /&gt;        &lt;/p&gt;      ))&#125;    &lt;/form&gt;  )&#125;\n\nReact将会以以下的形式更新：\nfor (let i = 0; i &lt; 10; i++) &#123;  let pNode = formNode.childNodes[i];  let textNode = pNode.firstChild;  textNode.textContent = 'You bought ' + items[i].name;&#125;\n\n\n因此我们需要一个唯一标识key，来告诉React渲染前后元素是否是相同的。\n\n组件和元素大同小异，React也会递归组件，渲染想要的元素。组件首字母必须大写，为了让React区分，告诉它这是一个组件而不是一个dom元素\n补充两个小点\n\n什么是Hooks？\n\n其实Hooks是绑定组件局部状态的特性。\n\n\n什么是局部状态\n\n局部状态是宿主实例相关的能拥有的状态，例如focus、selection等等。\n\n\n\n控制反转组件是函数，为什么不用函数调用，而用JSX的形式呢？\n\n我们自身调用函数，控制权在我们手里，用JSX的形式，React会为我们调用函数，这就是控制反转。使用控制反转有以下几个好处：\n组件 &gt; 函数 React组件帮助我们维护了局部状态\n组件参与协调 也就是说React调用组件，可以更了解宿主树的结构，便于进行比对\n组件推迟协调 不会引起渲染导致的主线程阻塞\n组件便于调试 React提供了丰富的组件调试工具\n组件可以懒加载 组件不会去执行不需要执行的东西，例如function Page(&#123; currentUser, children &#125;) &#123;    if (!currentUser.isLoggedIn) &#123;        return &lt;h1&gt;Please login&lt;/h1&gt;;    &#125;    return (        &lt;Layout&gt;            &#123;children&#125;        &lt;/Layout&gt;    );&#125;// 这里有个地方调用组件&lt;Page&gt;    &#123;Comments()&#125; // 这个Comments函数无论是否登录永远都将执行&lt;/Page&gt;// 这里有个地方调用组件&lt;Page&gt;    &lt;Comments /&gt; // 这个Comments组件&lt;/Page&gt;\n\n\n\n\n\n渲染阶段(React Fiber)和提交阶段class ClickCounter extends React.Component &#123;    constructor(props) &#123;        super(props);        this.state = &#123;count: 0&#125;;        this.handleClick = this.handleClick.bind(this);    &#125;    handleClick() &#123;        this.setState((state) =&gt; &#123;            return &#123; count: state.count + 1 &#125;;        &#125;);    &#125;        componentDidUpdate() &#123;&#125;    render() &#123;        return [            &lt;button key=\"1\" onClick=&#123;this.handleClick&#125;&gt;Update counter&lt;/button&gt;,            &lt;span key=\"2\"&gt;&#123;this.state.count&#125;&lt;/span&gt;        ]    &#125;&#125;\nReact Fiber什么是Fiber？为什么使用Fiber？看以下的图:\n\n\nReact 16版本之前，React完全通过stack reconciler进行比对(见图1)，这种比对会在setState进行后立即发生，会递归函数，当vDom遍历完成之后，得到对应的真实Dom的信息，并传递给render进行渲染。如果有大量的比对，那么会消耗过长的时间，浏览器线程此时被js代码所阻塞，如果遇到类似于动画效果，那么动画效果将被延迟执行，不仅如此，交互布局都将被阻塞，给用户的感觉就是卡顿的感觉。\n\n上述图片展示了stack工作时的内存情况，因此，React重写了其算法，使用了Fiber。\nSchedule(调度)调度是什么？—— 调度就是调动，安排人力，车辆。(来自百度百科)\n我们已经知道stack reconciler模式的弊端，比对占用大量时间，阻塞了主线程。因此，我们需要有人安排，何时能够进行比对。这种调度是Fiber reconciler中的过程之一，如果浏览器主线程的优先级高，那么我们优先进行浏览器想要进行的操作。类似于下图。\n\n如上图所示，我们需要达成此目的，我们需要拆分我们的宿主树，拆分成一个个片段，以链表的形式，为每个节点添加一些必要的数据结构，来达成连续的片段。并且这些连续的片段可以被高优先级的任务随时中断。\n这样引发一个问题，真实Dom与我当前的vDom不一致(由于我可能已经更新了一些片段)，因此，调度过程中，我们必须保存我们的调度信息，除了当前正在比对的树(current树)。我们还需要维护一棵正在比对的树，这棵树保存的是已经比对过的片段(workInProgress树)。\n怎么和浏览器进行通信，何时和浏览器进行通信呢?客户端执行任务按帧来计算，通常执行帧在30~60帧之间。在两个执行帧之间的空闲时间，通常被用来进行调度，执行任务。\n\n如上图所示，浏览器可以在这两个空闲期之间执行requestIdleCallback，浏览器同时也会传递给回调函数deadline相关的对象信息，如果说你这个fiber node执行时间过长，这个fiber node依旧会执行完才会去向浏览器征求意见，如果说你这个里面写了个死循环，那么页面将会卡死，通常一个fiber node不会超过16ms，超过了则将出现卡顿的情况。\n一个例子\n这个例子借用React Conf 2017上Lin Clark的演讲(附上链接)\n\n现在有一个列表，渲染一个button和一组item, item中包含一个div，其中的内容为数字。通过点击button，可以使列表中的所有数字进行平方。另外有一个按钮，点击可以调节字体大小。\n\n1.0 页面初始化完成，渲染一个fiber tree，如下图所示\n这里注意：每个fiber node，child指针指向的节点都为其直接子节点，至于其他子节点，将会由直接子节点的sibling指针指向，具体可见fiber数据结构，每个fiber node都向其父节点返回\n\n1.0.1 React同时维护用于计算更新，保存当前计算状态的树，称之为workInProgressTree，。\n\n1.1 用户点击平方操作，调用setState，React将其送入更新队列(update queue), 不会立即进行对比，修改dom，而是交给调度器(scheduler)\n\n1.2 调度器会去询问主线程的使用情况，上文已经描述了如何与浏览器进行通信，借用requestIdelCallback，根据优先级执行任务，低优先级通过requestIdelCallback，高优先级(动画)通过requestAnimationFrame执行。\n\n2.1 一旦调度器得到了时间，就开始进入了work loop，这种循环是等待与执行的循环，每次fiber node执行完成才会去询问浏览器主线程状态，上文说了，通常是在16ms之内完成，否则会有卡顿情况，如果写了死循环，依旧会导致页面卡死的情况。在这个过程中，当前的fiber node需要记住下一个工作单元，如果浏览器有时间，那么我将进行下一个fiber node的任务执行\n\n2.2 根节点上的更新队列为空，所以直接从fiber-tree上将根节点复制到workInProgressTree中去。根节点中包含指向子节点List的指针。\n\n2.3 根节点根据child指针，将List节点和对应的更新队列一起放到workInProgressTree中，List插入后返回给父节点，标志着根节点fiber node处理完成\n\n2.4 重复1.2操作，询问主线程情况\n\n3.1 处理下一个List节点，进入work loop，因此此时react会调用setState时传入的updater funciton获取最新的state值，此时应该是[1,4,9]\n\n在继续之前，我们简单回顾一下setState的前几步流程:\n触发setState函数，将触发setState的this和setState的参数传入enqueueSetState函数中。\nenqueueSetState函数，提出当前触发setState的Fiber节点并将传入的setState的参数创建一个update对象，update对象中的payload就是传入的state对象。\nenqueueUpdate函数，将当前Fiber的state和需要修改的state创建一个对象传入当前Fiber节点的updateQueue对象中。updateQueue对象有几个关键值，baseState(当前Fiber节点的state)、firstUpdate(首个更新任务)、lastUpdate(最后一个更新任务，防止多次重复setState)。\n\n\n\n在获取到最新的state值后，react会更新List的state和props值，并且根据element类型判断是否可重用，然后渲染到workInProgress树中，由于List组件有更新，因此我们需要将List打上标签，表明需要更新。\n\n3.2 重复1.2操作，询问主线程情况\n\n3.3 button没有子节点，也没有更新，因此直接标记button处理完成。\n\n3.4 重复1.2操作，询问主线程情况。由于我们点击了放大字体的操作，主线程已经有放大字体的操作在等待fiber node任务完成。\n\n3.5 对于每一个item,判断shouldComponentUpdate,如果不需要更新，那么我们像3.3中的button一样操作，如果需要更新，那么我们像3.1中的List一样操作，打需要更新的标签\n\n4.1 对于叶子节点div，无兄弟节点，更新操作也已结束，需要合并到父节点，才算fiber node完成。\n\n4.2 合并回到父节点，并移除标签，标记完成。\n\n4.3 重复1.2操作，询问主线程情况。现在有放大字体的操作在等待。因此交换主线程，放大字体。\n\n4.4 放大字体完成，React完成接下来的操作，形成一个完成的workInProgress树。\n\n4.5 那些更新的item向List返回, 标签列表如下\n\n4.6 所有节点标记完成后,React正式进入提交阶段,同样询问主线程,时间够用,更新Dom\n\n4.7 更新完过后还需要交换指针\n\n废除生命周期\n为什么Fiber Reconciler下, React要废除生命周期例如componentWillUpdate?\n\n我们通过刚刚Fiber Reconciler的过程我们看到, 这个过程是可以被高优先级例如动画所打断的, 我们初次调用componentWillUpdate, 结果我Reconciler到一半,被打断了, 当主线程又有时间的时候,我又要进行componentWillUpdate,显然是不合理的.\n","categories":["React"],"tags":["前端","React"]},{"title":"React-render阶段(一)","url":"/2021/06/01/React-render%E9%98%B6%E6%AE%B5%E4%B8%80/","content":"React-render阶段(一)概览React在16.8版本之后, 使用Fiber提供了任务的优先级，中断可恢复的能力(开启CM模式). React通过Scheduler将高优先级的任务率先扔进Reconciler, Reconcile阶段创建了每个节点(其中可能经历复用或者diff等),生成Fiber树,并生成对应的dom树(暂未插入到页面),这个阶段我们称之为render阶段(渲染阶段)\nReact Fiber使用了双缓存机制, 提供了两棵Fiber树, 当前展示的这棵树我们称之为current树(本次更新的上一次更新的树), 还有一棵是首次更新或者触发更新后在内存中生成的树, 我们称之为WorkInProgress树\n双缓存current树: current树上的每一个工作单元展示了当前页面的dom情况, 首屏渲染时, current树只存在应用程序的根rootFiber节点\nworkInProgress树: workInProgress树上的每一个工作单元的形成会在内存中执行, 渲染mount或者update时的更新逻辑\n\n具体可以参考卡老师写的React揭秘中理念篇的Fiber结构的工作原理,来详细的理解双缓存的概念——什么是双缓存。\n\n\n\n渲染阶段render阶段开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot,取决于当前的模式. 这个函数是React整个流程,包括render阶段和commit阶段\n\n上图红框标出三个断点, 第一个断点是render阶段的核心\nfunction renderRootSync(root, lanes) &#123;  // ......  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) &#123;    &#123;      if (isDevToolsPresent) &#123;        var memoizedUpdaters = root.memoizedUpdaters;        if (memoizedUpdaters.size &gt; 0) &#123;          restorePendingUpdaters(root, workInProgressRootRenderLanes);          memoizedUpdaters.clear();        &#125; // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.        // If we bailout on this work, we'll move them back (like above).        // It's important to move them now in case the work spawns more work at the same priority with different updaters.        // That way we can keep the current update and future updates separate.        movePendingFibersToMemoized(root, lanes);      &#125;    &#125;    // 重置调度队列,并从root节点(新的高优先级的节点)开始调度    prepareFreshStack(root, lanes);  &#125;  &#123;    markRenderStarted(lanes);  &#125;  do &#123;    try &#123;      // 尝试循环创建工作单元      workLoopSync();      break;    &#125; catch (thrownValue) &#123;      handleError(root, thrownValue);    &#125;  &#125; while (true); // .....  return workInProgressRootExitStatus;&#125; // Th\n这个方法最重要的两个方法, 一个是prepareFreshStack, 这个方法是用于重置调度队列,并从root节点(新的高优先级的节点)开始调度, 这个函数内部调用了createWorkInProgress, 我们放到下面一会讲\nfunction workLoopSync() &#123;  while (workInProgress !== null) &#123;    performUnitOfWork(workInProgress);  &#125;&#125;// performConcurrentWorkOnRoot会调用该方法function workLoopConcurrent() &#123;   //和上面的区别在于shouldYield, 这个代表是否存在剩余时间  while (workInProgress !== null &amp;&amp; !shouldYield()) &#123;    performUnitOfWork(workInProgress);  &#125;&#125;\n还有一个是workLoopSync, 循环创建调用performUnitOfWork, 通过函数名可以看到是循环执行工作单元, 为遍历到的每个Fiber节点提供beginWork\nfunction performUnitOfWork(unitOfWork) &#123;  var current = unitOfWork.alternate;  setCurrentFiber(unitOfWork);  var next;  if ( (unitOfWork.mode &amp; ProfileMode) !== NoMode) &#123;    startProfilerTimer(unitOfWork);    // 开始beginWork阶段, 主要是创建当前节点的子Fiber节点    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);  &#125; else &#123;    next = beginWork$1(current, unitOfWork, subtreeRenderLanes);  &#125;  resetCurrentFiber();  unitOfWork.memoizedProps = unitOfWork.pendingProps;  if (next === null) &#123;    // 如果子节点为null, 那么直接把当前节点completeWork    completeUnitOfWork(unitOfWork);  &#125; else &#123;    workInProgress = next;  &#125;  ReactCurrentOwner$2.current = null;&#125;\nbeginWork的主要作用在于创建当前节点的子Fiber节点, 该方法为render阶段递归阶段递阶段的主要方法\nbeginWorkfunction beginWork(current, workInProgress, renderLanes) &#123;  var updateLanes = workInProgress.lanes;  &#123;    if (workInProgress._debugNeedsRemount &amp;&amp; current !== null) &#123;      // This will restart the begin phase with a new fiber.      return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));    &#125;  &#125;  // 当前的workInProgress树上正在工作的单元对应的alternate对应的Fiber节点  if (current !== null) &#123;    var oldProps = current.memoizedProps;    var newProps = workInProgress.pendingProps;    if (oldProps !== newProps || hasContextChanged() || (     workInProgress.type !== current.type )) &#123;       // props或者context变化, 有更新的逻辑      didReceiveUpdate = true;    &#125; else if (!includesSomeLane(renderLanes, updateLanes)) &#123;// 当前fiber上是否存在更新，如果存在那么更新的优先级是否和本次整棵fiber树调度的优先级一致      // 以下表示当前fiber上的更新与本颗fiber树上的更新不一致或者说当前fiber上不存在更新      didReceiveUpdate = false;       // 这里主要是针对不接受更新的ReactElement对象, 进行复用, 针对不同的类型传递一些属性      switch (workInProgress.tag) &#123;         case HostRoot:          // ...        case // ...      &#125;      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);    &#125; else &#123;      if ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;        // 这个解决了context改变的时候suspense没有触发更新的问题        didReceiveUpdate = true;      &#125; else &#123;        didReceiveUpdate = false;      &#125;    &#125;  &#125; else &#123;    didReceiveUpdate = false;  &#125;  workInProgress.lanes = NoLanes;  switch (workInProgress.tag) &#123;    // 根据tag判断当前工作单元的类型, 基于当前类型进入不同的逻辑    case IndeterminateComponent:      // ...    case LazyComponent:      // ...    case FunctionComponent:      &#123;        var _Component = workInProgress.type;        var unresolvedProps = workInProgress.pendingProps;        var resolvedProps = workInProgress.elementType === _Component ? unresolvedProps : resolveDefaultProps(_Component, unresolvedProps);        return updateFunctionComponent(current, workInProgress, _Component, resolvedProps, renderLanes);      &#125;    case ClassComponent:      &#123;        var _Component2 = workInProgress.type;        var _unresolvedProps = workInProgress.pendingProps;        var _resolvedProps = workInProgress.elementType === _Component2 ? _unresolvedProps : resolveDefaultProps(_Component2, _unresolvedProps);        return updateClassComponent(current, workInProgress, _Component2, _resolvedProps, renderLanes);      &#125;    case HostRoot:      return updateHostRoot(current, workInProgress, renderLanes);    case HostComponent:      return updateHostComponent(current, workInProgress, renderLanes);    case xxxx:      // ..........  &#125;&#125;\n我们可以看到beginWork主要做了几件事情\n\n根据current判断这个工作单元处于挂载还是更新, 根据新旧props和context判断能否复用\n如果不能复用则更新, 根据当前工作单元的类型决定进入什么逻辑\n工作单元类型可以在src/react-reconciler/ReactWorkTags.js中找到, div属于HostComponent\n\n\n\nbeginWork中的更新逻辑(以div举例)如果当前工作单元是div, 那么会进入updateHostComponent的更新逻辑\nfunction updateHostComponent(current, workInProgress, renderLanes) &#123;  pushHostContext(workInProgress);  if (current === null) &#123;    tryToClaimNextHydratableInstance(workInProgress);  &#125;  var type = workInProgress.type;  var nextProps = workInProgress.pendingProps;  var prevProps = current !== null ? current.memoizedProps : null;  var nextChildren = nextProps.children;  var isDirectTextChild = shouldSetTextContent(type, nextProps);  // 文本节点的优化, 当div下只有一个单独的文本节点,那么react不会单独为这个Fiber节点创建子节点  if (isDirectTextChild) &#123;    nextChildren = null;  &#125; else if (prevProps !== null &amp;&amp; shouldSetTextContent(type, prevProps)) &#123;    workInProgress.flags |= ContentReset;  &#125;  markRef(current, workInProgress);  // reconcileChildren是diff子节点, 如果current是null, 说明是mount, 否则是update  reconcileChildren(current, workInProgress, nextChildren, renderLanes);  return workInProgress.child;&#125;\n针对div的更新, 主要调用了reconcileChilren的方法, 以下是reconcileChilren方法\nfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) &#123;  if (current === null) &#123;    // mount时    workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);  &#125; else &#123;    // update时    workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);  &#125;&#125;\nreconcileChilren在mount时调用了mountChildFibers, 在update时调用了reconcileChildFibers, 这两个方法都是调用的ChildReconciler, 返回一个节点并赋值给workInProgress.child, 因此可以验证beginWork的目的是创建当前节点的子Fiber 节点\nvar reconcileChildFibers = ChildReconciler(true);var mountChildFibers = ChildReconciler(false);\nChildReconciler的参数的含义代表的是是否需要追踪副作用, mount时不需要追踪副作用,原因是我们只需要被插入一次, 如果追踪副作用, 那么每个节点都将被打上effectTag为Placement(插入), 这样commit阶段所有节点都会被插入一次, 这种频繁操作dom的行为显然是消耗性能且没有必要的\nfunction ChildReconciler(shouldTrackSideEffects) &#123;  // ......其他节点的diff算法  // 这里只展示单一节点的diff算法的源码  function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) &#123;    var key = element.key;    var child = currentFirstChild;    while (child !== null) &#123;      // TODO: If key === null and child.key === null, then this only applies to      // the first item in the list.      if (child.key === key) &#123;        var elementType = element.type;        if (elementType === REACT_FRAGMENT_TYPE) &#123;          if (child.tag === Fragment) &#123;            deleteRemainingChildren(returnFiber, child.sibling);            var existing = useFiber(child, element.props.children);            existing.return = returnFiber;            &#123;              existing._debugSource = element._source;              existing._debugOwner = element._owner;            &#125;            return existing;          &#125;        &#125; else &#123;          if (child.elementType === elementType || ( // Keep this check inline so it only runs on the false path:           isCompatibleFamilyForHotReloading(child, element) ) || // Lazy types should reconcile their resolved type.          // We need to do this after the Hot Reloading check above,          // because hot reloading has different semantics than prod because          // it doesn't resuspend. So we can't let the call below suspend.           typeof elementType === 'object' &amp;&amp; elementType !== null &amp;&amp; elementType.$$typeof === REACT_LAZY_TYPE &amp;&amp; resolveLazy(elementType) === child.type) &#123;            deleteRemainingChildren(returnFiber, child.sibling);            var _existing = useFiber(child, element.props);            _existing.ref = coerceRef(returnFiber, child, element);            _existing.return = returnFiber;            &#123;              _existing._debugSource = element._source;              _existing._debugOwner = element._owner;            &#125;            return _existing;          &#125;        &#125; // Didn't match.        deleteRemainingChildren(returnFiber, child);        break;      &#125; else &#123;        deleteChild(returnFiber, child);      &#125;      child = child.sibling;    &#125;    if (element.type === REACT_FRAGMENT_TYPE) &#123;      var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);      created.return = returnFiber;      return created;    &#125; else &#123;      var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);      _created4.return = returnFiber;      return _created4;    &#125;  &#125;  function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) &#123;    var isUnkeyedTopLevelFragment = typeof newChild === 'object' &amp;&amp; newChild !== null &amp;&amp; newChild.type === REACT_FRAGMENT_TYPE &amp;&amp; newChild.key === null;    if (isUnkeyedTopLevelFragment) &#123;      newChild = newChild.props.children;    &#125; // Handle object types    if (typeof newChild === 'object' &amp;&amp; newChild !== null) &#123;      switch (newChild.$$typeof) &#123;        case REACT_ELEMENT_TYPE:          return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));        case REACT_PORTAL_TYPE:          return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));        case REACT_LAZY_TYPE:          &#123;            var payload = newChild._payload;            var init = newChild._init; // TODO: This function is supposed to be non-recursive.            return reconcileChildFibers(returnFiber, currentFirstChild, init(payload), lanes);          &#125;      &#125;    &#125;    // return deleteRemainingChildren(returnFiber, currentFirstChild);  &#125;  return reconcileChildFibers;&#125;\n手动执行ChildReconciler会返回reconcileChildFibers, 这里巧妙的使用了闭包, 根据newChild中的$$typeof去进行不同逻辑.参数的newChild可以看到向上追溯看到是当前workInProgress.pendingProps.children, 也就是当前工作单元props上的childrenreconcileSingleElement代码已经展示在上面, 是单一节点的diff算法, 等讲到diff算法时在详细解读\nfunction placeSingleChild(newFiber) &#123;  // This is simpler for the single child case. We only need to do a  // placement for inserting new children.  if (shouldTrackSideEffects &amp;&amp; newFiber.alternate === null) &#123;    newFiber.flags |= Placement;  &#125;  return newFiber;&#125;\nplaceSingleChild就是为新节点添加Placement操作(mount时不添加), 并将其返回并添加到workInProgress.child上\n以上为beginWork的完整流程, 目的在于创建当前工作单元的第一个子Fiber节点\n\n接下来补充一点逻辑, 为了方便调试, 并解决一些个人遇到的疑难困惑点\nbailoutOnAlreadyFinishedWorkfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) &#123;  if (current !== null) &#123;    workInProgress.dependencies = current.dependencies;  &#125;  &#123;    stopProfilerTimerIfRunning();  &#125;  markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.  if (!includesSomeLane(renderLanes, workInProgress.childLanes)) &#123;    &#123;      return null;    &#125;  cloneChildFibers(current, workInProgress);  return workInProgress.child;&#125;\n这个函数的作用在于复用Fiber节点, 函数调用的时机仅仅会发生在update时, 根据双缓存机制, 当更新时, current树已经存在对应的Fiber节点, 在上文beginWork中有以下这么一段代码, 我们可以看到当current树不为null并且新旧Props context和type无变化的时候, 会复用节点(即return bailoutOnAlreadyFinishedWork),bailoutOnAlreadyFinishedWork调用cloneChildFibers\n// 当前的workInProgress树上正在工作的单元对应的alternate对应的Fiber节点if (current !== null) &#123;  var oldProps = current.memoizedProps;  var newProps = workInProgress.pendingProps;  if (oldProps !== newProps || hasContextChanged() || (   workInProgress.type !== current.type )) &#123;     // props或者context变化, 有更新的逻辑    didReceiveUpdate = true;  &#125; else if (!includesSomeLane(renderLanes, updateLanes)) &#123;    didReceiveUpdate = false;     // 这里主要是针对不接受更新的ReactElement对象, 进行复用, 针对不同的类型传递一些属性    switch (workInProgress.tag) &#123;       case HostRoot:        // ...      case // ...    &#125;    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);  &#125; else &#123;    if ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;      // 这个解决了context改变的时候suspense没有触发更新的问题      didReceiveUpdate = true;    &#125; else &#123;      didReceiveUpdate = false;    &#125;  &#125;&#125; else &#123;  didReceiveUpdate = false;&#125;\n\ncloneChildFibersfunction cloneChildFibers(current, workInProgress) &#123;  if (!(current === null || workInProgress.child === current.child)) &#123;    &#123;      throw Error( \"Resuming work not yet implemented.\" );    &#125;  &#125;  if (workInProgress.child === null) &#123;    return;  &#125;  var currentChild = workInProgress.child;  var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);  workInProgress.child = newChild;  newChild.return = workInProgress;  while (currentChild.sibling !== null) &#123;    currentChild = currentChild.sibling;    newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);    newChild.return = workInProgress;  &#125;  newChild.sibling = null;&#125;\n从名称可以读出, 这个函数的作用就是clone当前工作单元的子Fiber节点, 那么复用节点目的就是把current树上对应的现在Fiber节点的子Fiber节点保存到当前工作单元的child属性下, 这个方法会调用createWorkInProgress, 所以调用createWorkInProgress目的创建的不是当前工作单元, 而是当前工作单元的子工作单元\ncreateWorkInProgressfunction createWorkInProgress(current, pendingProps) &#123;  var workInProgress = current.alternate;  if (workInProgress === null) &#123;    // 如果workInProgress是null, 那么为其创建一个Fiber节点    workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);    workInProgress.elementType = current.elementType;    workInProgress.type = current.type;    workInProgress.stateNode = current.stateNode;    // ...省略部分赋值    // 连接两课Fiber树    workInProgress.alternate = current;    current.alternate = workInProgress;  &#125; else &#123;    workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.    workInProgress.type = current.type; // We already have an alternate.    // Reset the effect tag.    workInProgress.flags = NoFlags; // The effects are no longer valid.    workInProgress.subtreeFlags = NoFlags;    workInProgress.deletions = null;    // ...省略部分代码  &#125;   workInProgress.flags = current.flags &amp; StaticMask;  workInProgress.childLanes = current.childLanes;  workInProgress.lanes = current.lanes;  workInProgress.child = current.child;  workInProgress.memoizedProps = current.memoizedProps;  workInProgress.memoizedState = current.memoizedState;  workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so  // it cannot be shared with the current fiber.  var currentDependencies = current.dependencies;  workInProgress.dependencies = currentDependencies === null ? null : &#123;    lanes: currentDependencies.lanes,    firstContext: currentDependencies.firstContext  &#125;; // These will be overridden during the parent's reconciliation  workInProgress.sibling = current.sibling;  workInProgress.index = current.index;  workInProgress.ref = current.ref;  // ...省略部分代码  return workInProgress;&#125;\ncreateWorkInProgress从名称可以看出作用在于创建workInProgress节点, 这个函数的调用时机在cloneChildFibers或者prepareFreshStack中. 这个函数首先判断current.alternate是否为空, 这里解释一下, current.alternate为空说明当前工作单元的子工作单元是更新后新创建的, 这个时候我们会为新的工作单元创建一个Fiber节点, 否则我们对子工作单元进行一个赋值操作即可\n全流程这里梳理一下上述所说的全流程\n\n","categories":["React"],"tags":["前端","React","源码系列"]},{"title":"React-render阶段(二)","url":"/2021/06/12/React-render%E9%98%B6%E6%AE%B5%E4%BA%8C/","content":"React-render阶段(二)概览React-render阶段一解释了当组件进入reconciler后的执行过程, 从root节点开始调度, 循环调用beginWork创建子节点. 其中创建子节点的过程又分为挂载阶段和更新阶段, 挂载阶段不追踪副作用, 更新阶段追踪副作用, 更新阶段又分为可复用和不可复用, 可复用的会进入bailout的复用逻辑, 会把current树中的当前节点以及其子节点复制到workInProgress树中, 没有进入bailout阶段的Fiber节点会进入diff算法(对应的current中的Fiber节点与返回的JSX对比, 生成新的Fiber节点), 并为新的Fiber节点打上effectTag\n当前Fiber节点没有子节点时就进入了completeWork, 可以理解为递归阶段的归阶段, completeWork的目的就是为了创建好对应的dom节点插入对应的父级节点的dom节点, 为其添加副作用标识, 再commit阶段将对应的节点展示到页面上并执行对应的副作用.\n以下我以cra创建的项目的代码举例, js如下\nfunction App() &#123;  const [num, setNum] = useState(0)  return (    &lt;div className=\"App\"&gt;      &lt;header className=\"App-header\"&gt;        &lt;img src=&#123;logo&#125; className=\"App-logo\" alt=\"logo\" /&gt;        &lt;p onClick=&#123;() =&gt; &#123; setNum(num + 1) &#125;&#125;&gt;          &#123;num&#125; &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.        &lt;/p&gt;        &lt;a          className=\"App-link\"          href=\"https://reactjs.org\"          target=\"_blank\"          rel=\"noopener noreferrer\"        &gt;          Learn React        &lt;/a&gt;      &lt;/header&gt;    &lt;/div&gt;  );&#125;\n\n\n\nCompleteWork执行时机与分析completeWork发生在当前Fiber节点没有子节点的情况下, 源码发生在performUnitOfWork函数中, 这个函数发生在上文提到过的workLoopSync中, 这个函数将被循环调用上图打了两个断点处就是completeWork是否执行的条件, 第一个断点拿到的是beginWork创建好的子Fiber节点, 如果没有子Fiber节点则返回null, 只有当next为null的时候才会进入completeWork, completeWork的开始源于他的上层函数completeUnitOfWork\nfunction completeUnitOfWork(unitOfWork) &#123;  var completedWork = unitOfWork; // 获取当前completeWork的Fiber节点  do &#123;    var current = completedWork.alternate; // 获取当前completeWork对应的current树上的节点, 没有则表示是新增的节点    var returnFiber = completedWork.return;     if ((completedWork.flags &amp; Incomplete) === NoFlags) &#123;      setCurrentFiber(completedWork);      var next = void 0;      if ( (completedWork.mode &amp; ProfileMode) === NoMode) &#123;        next = completeWork(current, completedWork, subtreeRenderLanes);      &#125; else &#123;        startProfilerTimer(completedWork);        next = completeWork(current, completedWork, subtreeRenderLanes); // Update render duration assuming we didn't error.        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);      &#125;      resetCurrentFiber();      if (next !== null) &#123;        workInProgress = next;        return;      &#125;    &#125; else &#123;      var _next = unwindWork(completedWork, subtreeRenderLanes); // Because this fiber did not complete, don't reset its expiration time.      if (_next !== null) &#123;        _next.flags &amp;= HostEffectMask;        workInProgress = _next;        return;      &#125;      if ( (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false); // Include the time spent working on failed children before continuing.        var actualDuration = completedWork.actualDuration;        var child = completedWork.child;        while (child !== null) &#123;          actualDuration += child.actualDuration;          child = child.sibling;        &#125;        completedWork.actualDuration = actualDuration;      &#125;      if (returnFiber !== null) &#123;        returnFiber.flags |= Incomplete;        returnFiber.subtreeFlags = NoFlags;        returnFiber.deletions = null;      &#125;    &#125;    var siblingFiber = completedWork.sibling;    if (siblingFiber !== null) &#123;      // If there is more work to do in this returnFiber, do that next.      workInProgress = siblingFiber;      return;    &#125; // Otherwise, return to the parent    completedWork = returnFiber; // Update the next thing we're working on in case something throws.    workInProgress = completedWork;  &#125; while (completedWork !== null); // We've reached the root.  if (workInProgressRootExitStatus === RootIncomplete) &#123;    workInProgressRootExitStatus = RootCompleted;  &#125;&#125;\ncompleteUnitOfWork从源码中可以看到是一个do while循环, 终止条件有completeWork !== null或者循环内return前的几个终止条件, 我们可以看到有一个是siblingFiber不为null的情况. 即当前的节点存在兄弟节点时并且已经没有子节点, 当前节点会结束completeWork, 跳出调用栈, 执行下一次循环, 进入兄弟节点的beginWork.当兄弟节点为null的时候, 那么completeWork会被赋值为returnFiber, 这个时候注意并没有用return跳出调用栈, 因为父级节点的beginWork已经被执行, 因此会进入父级节点的completeWork, 由此向上, 当completeWork为null时意味着归到根节点\n接下来分析一下completeWork做的具体的事情\nfunction completeWork(current, workInProgress, renderLanes) &#123;  console.log('completeWork', 'tag:', workInProgress.tag, ' type:', workInProgress.type);  var newProps = workInProgress.pendingProps;  switch (workInProgress.tag) &#123;    case IndeterminateComponent:    case LazyComponent:    case SimpleMemoComponent:    case FunctionComponent:    case ForwardRef:    case Fragment:    case Mode:    case Profiler:    case ContextConsumer:    case MemoComponent:      bubbleProperties(workInProgress);      return null;    case ClassComponent:      &#123;        var Component = workInProgress.type;        if (isContextProvider(Component)) &#123;          popContext(workInProgress);        &#125;        bubbleProperties(workInProgress);        return null;      &#125;    case HostComponent:      &#123;        popHostContext(workInProgress);        var rootContainerInstance = getRootHostContainer();        var type = workInProgress.type;        if (current !== null &amp;&amp; workInProgress.stateNode != null) &#123;          updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);          if (current.ref !== workInProgress.ref) &#123;            markRef$1(workInProgress);          &#125;        &#125; else &#123;          if (!newProps) &#123;            if (!(workInProgress.stateNode !== null)) &#123;              &#123;                throw Error( \"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\" );              &#125;            &#125; // This can happen when we abort work.            bubbleProperties(workInProgress);            return null;          &#125;          var currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context          // \"stack\" as the parent. Then append children as we go in beginWork          // or completeWork depending on whether we want to add them top-&gt;down or          // bottom-&gt;up. Top-&gt;down is faster in IE11.          var _wasHydrated = popHydrationState(workInProgress);          if (_wasHydrated) &#123;            // TODO: Move this and createInstance step into the beginPhase            // to consolidate.            if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) &#123;              // If changes to the hydrated node need to be applied at the              // commit-phase we mark this as such.              markUpdate(workInProgress);            &#125;          &#125; else &#123;            var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);            appendAllChildren(instance, workInProgress, false, false);            workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.            // (eg DOM renderer supports auto-focus for certain elements).            // Make sure such renderers get scheduled for later work.            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) &#123;              markUpdate(workInProgress);            &#125;          &#125;          if (workInProgress.ref !== null) &#123;            // If there is a ref on a host node we need to schedule a callback            markRef$1(workInProgress);          &#125;        &#125;        bubbleProperties(workInProgress);        return null;      &#125;    // ...以下省略的是针对其他组件的执行逻辑, 这里我们重点关注前几个&#125;\n上面的代码中看到completeWork函数就是针对不同的Fiber节点的Tag, 处理不同的逻辑, 我们根据p标签为例, 会进入case为HostComponent的分支\n// completeWork顺序如下(展示一部分, 归到p标签为止)1. img2. &#123;num&#125;3. num后面的空格4. code5.  and save to reload.6. p\n\nmount阶段根据上面的completeWork的分析, 我们直接看上面 HostComponent 的逻辑, 一行一行看开始的逻辑都是一样的, 首先处理context, 获取根容器\n\npopHostContext是和context相关的逻辑, 暂时跳过\nrootContainerInstance是获取根容器&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;接下来的逻辑会根据挂载和更新进入不同的条件语句, 重新贴一下核心代码if (current !== null &amp;&amp; workInProgress.stateNode != null) &#123;    updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);    if (current.ref !== workInProgress.ref) &#123;    markRef$1(workInProgress);    &#125;&#125; else &#123;    if (!newProps) &#123; // 如果没有新的props并且stateNode为null, 可能是React发生了内部错误, 挂载时newProps至少也是一个&#123;&#125;, 一定不会进这里        if (!(workInProgress.stateNode !== null)) &#123;            &#123;                throw Error( \"We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.\" );            &#125;        &#125; // This can happen when we abort work.        bubbleProperties(workInProgress);        return null;    &#125;    var currentHostContext = getHostContext(); // context相关    var _wasHydrated = popHydrationState(workInProgress); // 服务端渲染相关    if (_wasHydrated) &#123;// 服务端渲染        if (prepareToHydrateHostInstance(workInProgress, rootContainerInstance, currentHostContext)) &#123;                        markUpdate(workInProgress);        &#125;    &#125; else &#123;        var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress);        appendAllChildren(instance, workInProgress, false, false);        workInProgress.stateNode = instance; // Certain renderers require commit-time effects for initial mount.        // (eg DOM renderer supports auto-focus for certain elements).        // Make sure such renderers get scheduled for later work.            if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) &#123;                markUpdate(workInProgress);            &#125;        &#125;        if (workInProgress.ref !== null) &#123;            // If there is a ref on a host node we need to schedule a callback            markRef$1(workInProgress);        &#125;&#125;\n跳过context相关和服务端渲染相关, 会进入 instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress), 这里主要是创建dom实例, 进去看下这个函数function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) &#123;  var parentNamespace;  &#123;    var hostContextDev = hostContext;    // 检测dom是否正确嵌套    validateDOMNesting(type, null, hostContextDev.ancestorInfo);    if (typeof props.children === 'string' || typeof props.children === 'number') &#123;      var string = '' + props.children;      var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);      validateDOMNesting(null, string, ownAncestorInfo);    &#125;    parentNamespace = hostContextDev.namespace;  &#125;  // 创建dom实例  var domElement = createElement(type, props, rootContainerInstance, parentNamespace);  // 缓存这个fiber节点  precacheFiberNode(internalInstanceHandle, domElement);  // 更新fiber节点的props, react会自己定义一个值, 所有的props将存放在当前的dom实例上  updateFiberProps(domElement, props);  return domElement;&#125;\n返回创建好的domElement, 然后直接插入逻辑, 对应的代码为appendAllChildren(instance, workInProgress, false, false);, 看下这个函数appendAllChildren = function (parent, workInProgress, needsVisibilityToggle, isHidden) &#123;    // 拿到当前工作单元的child Fiber节点, 即拿到第一个子节点    var node = workInProgress.child;    while (node !== null) &#123;        if (node.tag === HostComponent || node.tag === HostText) &#123; // 如果是文本节点或者是原生dom节点            // 这个函数调用的就是parent.appendChild(node.stateNode);            appendInitialChild(parent, node.stateNode);        &#125; else if (node.tag === HostPortal) ; else if (node.child !== null) &#123;            node.child.return = node;            node = node.child;            continue;        &#125;        if (node === workInProgress) &#123; // 如果是当前工作单元, 插入完毕            return;        &#125;        while (node.sibling === null) &#123; // 没有兄弟节点则Fiber向上冒泡            if (node.return === null || node.return === workInProgress) &#123;                return;            &#125;            node = node.return;        &#125;        node.sibling.return = node.return; // 把兄弟节点的return节点赋值给父节点        node = node.sibling; // 把node赋值为兄弟节点    &#125;&#125;;\nappendAllChildren的作用和函数名相同, 目的就是把当前工作单元的所有子节点全部插入到刚创建好的dom实例中, 全部插入完毕执行workInProgress.stateNode = instance;, 这里采用的是深度优先遍历的方式此时这里的instance为插入完的dom实例, 并把对应的节点赋值到当前Fiber节点的stateNode上\n\n然后执行的是finalizeInitialChildren方法, 此方法调用了setInitialProperties\nfunction setInitialProperties(domElement, tag, rawProps, rootContainerElement) &#123;  var isCustomComponentTag = isCustomComponent(tag, rawProps);  &#123;    validatePropertiesInDevelopment(tag, rawProps);  &#125; // TODO: Make sure that we check isMounted before firing any of these events.  var props;  switch (tag) &#123;    // 跳过一些dom节点的判断逻辑    default:      props = rawProps;  &#125;  // 判断props是否合法  assertValidProps(tag, props);  // 设置初始化的dom属性  setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);  switch (tag) &#123;    case 'input':      track(domElement);      postMountWrapper(domElement, rawProps, false);      break;    case 'textarea':      track(domElement);      postMountWrapper$3(domElement);      break;    case 'option':      postMountWrapper$1(domElement, rawProps);      break;    case 'select':      postMountWrapper$2(domElement, rawProps);      break;    default:      if (typeof props.onClick === 'function') &#123;        // TODO: This cast may not be sound for SVG, MathML or custom elements.        trapClickOnNonInteractiveElement(domElement);      &#125;      break;  &#125;&#125;\n上面的函数主要是判断了props是否合法, 并对特殊的dom节点做了一些操作, 并把初始化的属性赋值到当前的dom上\nfunction setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) &#123;  for (var propKey in nextProps) &#123;    if (!nextProps.hasOwnProperty(propKey)) &#123;      continue;    &#125;    var nextProp = nextProps[propKey];    if (propKey === STYLE) &#123; // style的时候      &#123;        if (nextProp) &#123;          Object.freeze(nextProp);        &#125;      &#125;      setValueForStyles(domElement, nextProp);    &#125; else if (propKey === DANGEROUSLY_SET_INNER_HTML) &#123; // dangerouslySetInnerHTML      var nextHtml = nextProp ? nextProp[HTML$1] : undefined;      if (nextHtml != null) &#123;        setInnerHTML(domElement, nextHtml);      &#125;    &#125; else if (propKey === CHILDREN) &#123; // children      if (typeof nextProp === 'string') &#123;  // 如果节点是字符串        var canSetTextContent = tag !== 'textarea' || nextProp !== '';        if (canSetTextContent) &#123;          setTextContent(domElement, nextProp);        &#125;      &#125; else if (typeof nextProp === 'number') &#123; // 如果是数字就转换为字符串        setTextContent(domElement, '' + nextProp);      &#125;    &#125; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) &#123;      if (nextProp != null) &#123;        if ( typeof nextProp !== 'function') &#123;          warnForInvalidEventListener(propKey, nextProp);        &#125;        if (propKey === 'onScroll') &#123;          listenToNonDelegatedEvent('scroll', domElement);        &#125;      &#125;    &#125; else if (nextProp != null) &#123;      setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);    &#125;  &#125;&#125;\n复制初始化的props是调用了setInitialDOMProperties, 这个函数循环调用了新的props, 并对每个propKey做了特定的赋值操作, 这一步主要在setValueForProperty中, 这一步会调用node.setAttribute来为创建好的dom元素设置属性\n继续走下去进行的是判断是否存在ref, 如果存在ref则调用markRef$1(workInProgress);函数\n最后执行bubbleProperties\nif ( (completedWork.mode &amp; ProfileMode) !== NoMode) &#123;      var actualDuration = completedWork.actualDuration;      var treeBaseDuration = completedWork.selfBaseDuration;      var child = completedWork.child;      while (child !== null) &#123;        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));        subtreeFlags |= child.subtreeFlags;        subtreeFlags |= child.flags;        actualDuration += child.actualDuration;        treeBaseDuration += child.treeBaseDuration;        child = child.sibling;      &#125;      completedWork.actualDuration = actualDuration;      completedWork.treeBaseDuration = treeBaseDuration;\nbubbleProperties 根据fiber.child及fiber.child.sibling更新subtreeFlags和childLanes, 主要是为了标记子树有没有更新, 这样可以通过 fiber.subtreeFlags 快速判断子树是否有副作用钩子，不需要深度遍历. 在React17版本后使用subtreeFlags替换了finishWork.firstEffect的副作用链表, 操作主要发生在bubbleProperties函数中, 核心代码如下\nupdate阶段当进入update阶段, 假如我们把p节点的Fiber作为案例, 对应case为HostComponent会进入以下的条件分支\nif (current !== null &amp;&amp; workInProgress.stateNode != null) &#123;    updateHostComponent$1(current, workInProgress, type, newProps, rootContainerInstance);    if (current.ref !== workInProgress.ref) &#123;        markRef$1(workInProgress);    &#125;&#125;\nupdateHostComponent$1代码如下\nupdateHostComponent$1 = function (current, workInProgress, type, newProps, rootContainerInstance) &#123;    var oldProps = current.memoizedProps; // 此状态为更新, 获取current的props    if (oldProps === newProps) &#123; // 判断props是否相同, 相同表示进入了bailout阶段,哪怕children变了我们也不需要做什么操作,因此直接跳过      return;    &#125;    var instance = workInProgress.stateNode; // 获取实例    var currentHostContext = getHostContext();    var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);    workInProgress.updateQueue = updatePayload;    if (updatePayload) &#123;      // 标记更新, 内部直接设置workInProgress.flags |= Update      markUpdate(workInProgress);    &#125;  &#125;;\n这里调用了一个主要的更新方法为prepareUpdate, 返回的updatePayload将被加入工作单元的更新队列中, 这个函数调用了diffProperties, 其中返回的updatePayload是一个数组, 第i项是对应的propKey, 第i + 1项是对应的value, 当存在updatePayload的时候意味着这个HostComponent存在增,或者更新的情况, 会调用markUpdate进行更新\nfunction diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) &#123;  &#123;    validatePropertiesInDevelopment(tag, nextRawProps);  &#125;  var updatePayload = null;  var lastProps;  var nextProps;  switch (tag) &#123;    // 这里省略了对特性的dom标签比如(input, select等)赋值lastProps和nextProps的过程    default:      lastProps = lastRawProps;      nextProps = nextRawProps;      if (typeof lastProps.onClick !== 'function' &amp;&amp; typeof nextProps.onClick === 'function') &#123;        trapClickOnNonInteractiveElement(domElement);      &#125;      break;  &#125;  // 检验props  assertValidProps(tag, nextProps);  var propKey;  var styleName;  var styleUpdates = null;    for (propKey in lastProps) &#123;    // 针对删除的情况, 需要标记对应的propKey为null    if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) &#123;      continue;    &#125;    if (propKey === STYLE) &#123;      var lastStyle = lastProps[propKey];      for (styleName in lastStyle) &#123;        if (lastStyle.hasOwnProperty(styleName)) &#123;          if (!styleUpdates) &#123;            styleUpdates = &#123;&#125;;          &#125;          styleUpdates[styleName] = '';        &#125;      &#125;    &#125; else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN) ; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (propKey === AUTOFOCUS) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) &#123;      if (!updatePayload) &#123;        updatePayload = [];      &#125;    &#125; else &#123;      (updatePayload = updatePayload || []).push(propKey, null);    &#125;  &#125;  for (propKey in nextProps) &#123;    var nextProp = nextProps[propKey];    var lastProp = lastProps != null ? lastProps[propKey] : undefined;    // 针对新增或者更新的情况, 需要标记对应的propKey为null    if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null &amp;&amp; lastProp == null) &#123; // 对应props被删除的情况      continue;    &#125;    if (propKey === STYLE) &#123;      &#123;        if (nextProp) &#123;          Object.freeze(nextProp);        &#125;      &#125;      if (lastProp) &#123;        // 在 `lastProp` 上取消设置样式，但不在 `nextProp` 上设置.        for (styleName in lastProp) &#123;          if (lastProp.hasOwnProperty(styleName) &amp;&amp; (!nextProp || !nextProp.hasOwnProperty(styleName))) &#123;            if (!styleUpdates) &#123;              styleUpdates = &#123;&#125;;            &#125;            styleUpdates[styleName] = '';          &#125;        &#125; // 从lastProps中的style更新数据.        for (styleName in nextProp) &#123;          if (nextProp.hasOwnProperty(styleName) &amp;&amp; lastProp[styleName] !== nextProp[styleName]) &#123;            if (!styleUpdates) &#123;              styleUpdates = &#123;&#125;;            &#125;            styleUpdates[styleName] = nextProp[styleName];          &#125;        &#125;      &#125; else &#123;        if (!styleUpdates) &#123;          if (!updatePayload) &#123;            updatePayload = [];          &#125;          updatePayload.push(propKey, styleUpdates);        &#125;        styleUpdates = nextProp;      &#125;    &#125; else if (propKey === DANGEROUSLY_SET_INNER_HTML) &#123;      var nextHtml = nextProp ? nextProp[HTML$1] : undefined;      var lastHtml = lastProp ? lastProp[HTML$1] : undefined;      if (nextHtml != null) &#123;        if (lastHtml !== nextHtml) &#123;          (updatePayload = updatePayload || []).push(propKey, nextHtml);        &#125;      &#125;    &#125; else if (propKey === CHILDREN) &#123;      if (typeof nextProp === 'string' || typeof nextProp === 'number') &#123;        (updatePayload = updatePayload || []).push(propKey, '' + nextProp);      &#125;    &#125; else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING) ; else if (registrationNameDependencies.hasOwnProperty(propKey)) &#123;      if (nextProp != null) &#123;        if ( typeof nextProp !== 'function') &#123;          warnForInvalidEventListener(propKey, nextProp);        &#125;        if (propKey === 'onScroll') &#123;          listenToNonDelegatedEvent('scroll', domElement);        &#125;      &#125;      if (!updatePayload &amp;&amp; lastProp !== nextProp) &#123;        updatePayload = [];      &#125;    &#125; else if (typeof nextProp === 'object' &amp;&amp; nextProp !== null &amp;&amp; nextProp.$$typeof === REACT_OPAQUE_ID_TYPE) &#123;      nextProp.toString();    &#125; else &#123;      (updatePayload = updatePayload || []).push(propKey, nextProp);    &#125;  &#125;  if (styleUpdates) &#123;    &#123;      validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);    &#125;    (updatePayload = updatePayload || []).push(STYLE, styleUpdates);  &#125;  return updatePayload;&#125;\n执行完这个diffProperties, 再执行bubbleProperties(workInProgress), 然后就结束了当前节点的completeWork\n注意点\nFiber的tag为function的时候是不会进入completeWork的\n挂载的时候插入的dom节点的获取方式在于完成的finishedWork, 在performSyncWorkOnRoot函数中\nReact17之前原本有一根finishWork.firstEffect开始的副作用链表, 始终指向的是第一个产生副作用的链表, 链表的nextEffect指向的是下一个具有副作用的链表, 这根链表在React17版本后使用subtreeFlags替换了, 操作主要发生在bubbleProperties函数中\n\n全流程这里梳理一下上述所说的全流程\n\n","categories":["React"],"tags":["前端","React","源码系列"]},{"title":"Redux","url":"/2020/08/02/Redux/","content":"本文默认会使用基本的Redux, 主要对自己学习Redux中一些比较困难的点进行思考和学习.\nRedux阅读和使用上遇到的一些难点reducer实现一个简易的ReduxcreateStoreProviderconnectmiddleWareReact-Redux HooksuseStoreuseSelectuseDispatch","categories":["React"],"tags":["前端","React","Redux"]},{"title":"TCP相关(持续更新)","url":"/2022/06/22/TCP%E7%9B%B8%E5%85%B3/","content":"TCP三次握手\n客户端向服务端发送标记位为SYN，序列号seq = x，发起连接\n\n服务端向客户端响应，发送SYN和ACK的标记位，seq = y, ack = x + 1的序列号\n\n客户端向服务端响应，发送ACK为标记位，ack = y + 1的序列号\n\n\n四次挥手\n客户端向服务端发起断开连接的请求，FIN作为标记位，seq = p作为序列号\n\n服务端响应客户端，ACK作为标志位，ack = p + 1\n\n服务端向客户端发起可以关闭的请求，FIN ACK作为标记位，seq = q，ack = p + 1\n\n客户端响应服务端的关闭请求，ACK作为标记位，ack = q + 1，服务端关闭\n\n客户端等待两个MSL后关闭\n\n\nDoS/DDoS发送请求连接的握手之后，会进入半连接状态，进入半连接队列。\n原理：DDoS就是伪造客户端，疯狂发请求导致服务器资源耗尽\n解决方案：响应后不分配资源，设置Cookie，客户端第三次握手的时候带上这个Cookie给服务端做校验\n流量控制滑动窗口本质就是双指针，两个队列，一个发送窗口，一个接收窗口\n发送窗口有以下几个\n\n已发送已响应\n已发送未响应\n未发送已响应\n未发送未响应\n\n接收窗口有以下几个\n\n已接收已响应\n已接收未响应\n\n流量控制逻辑：\n\n假设两个队列默认窗口200\n客户端发了200个字节，服务端处理了前100个之后，后面只能处理40个\n服务端可用窗口缩小60个，还剩140，因为还有60没处理\n服务端ack报文告诉客户端处理情况，客户端缩小为140，因为还有60个待发\n\n拥塞控制拥塞窗口拥塞窗口可以理解为发送窗口的限制，发送窗口的实际大小为Min{拥塞窗口， 接收窗口}\n慢启动拥塞窗口大小随着收到的ack的增加而增加，每次+1\n选择性重传发了1-7个包，丢了第5个，那么会通过left edge和right edge告知发送端已经收到了哪些区间的数据报，第5个包没到就重传这个包，叫选择性重传\n"},{"title":"css八股文","url":"/2022/07/01/css%E5%85%AB%E8%82%A1%E6%96%87/","content":""},{"title":"TS高级类型","url":"/2022/07/28/TS%E9%AB%98%E7%BA%A7%E7%B1%BB%E5%9E%8B/","content":"高级类型","categories":["TypeScript"],"tags":["TypeScript"]},{"title":"lerna包管理","url":"/2022/09/18/lerna%E5%8C%85%E7%AE%A1%E7%90%86/","content":"lerna包管理简述目前项目使用lerna来进行包管理，已经停止维护\n除了lerna以外，Rush也是一个非常不错的工具，lerna的停止维护目前看来是利好Rush的\nlerna和Rush解决的都是采用monorepo管理模式的项目\n\nmonorepo管理模式：monorepo是一种将多个package放在一个repo中的代码管理模式，摒弃了传统的多个package多个repo的模式\n\n解决的问题：\n多个包多个项目难以维护和发布\n模块的升级需要手动修改包信息\n公用npm包的node_modules占用大量空间\n\n带来的问题:\n单包的权限控制无法实现\n单项目过大的体积\n\n使用lerna管理的包目前Babel, React, Angular, Ember, Meteor, Jest等许多开源项目都使用该种模式来管理代码。\nlerna基本使用官方文档\n官网过于简单，结合了几篇教程以及自己的实践结果来搭一个较为完整的monorepo\n安装npm install lerna -g\n初始化初始化git在自己的github repositories中提前创建了一个空文件夹，并clone下来\n初始化lerna对应文件目录下执行lerna init, 对应生成两个文件一个文件夹\n根目录的lerna.json可以用来配置一些全局性的东西，比如npmClient，项目使用yarn，这里就给他配置为yarn，pnpm也是支持的，只需要正确配置包即可\nlerna.json\n&#123;      \"$schema\": \"node_modules/lerna/schemas/lerna-schema.json\", // IDE 或其它工具将会根据目标地址中的 schema 定义对 JSON 文件进行检查和智能提示等等  \"useNx\": true, // 搭配Nx使用  \"useWorkspaces\": true, // 使用 Workspaces  \"version\": \"0.0.0\", // 版本  \"npmClient\": \"yarn\"&#125;\n\n\npackage.json\n&#123;  \"name\": \"root\",  \"private\": true, // 主包不发布  \"workspaces\": [ // 工作区范围    \"packages/*\"  ],  \"devDependencies\": &#123;    \"lerna\": \"^5.5.0\"  &#125;&#125;\n\n创建工具包lerna create public-package\n命令执行结果\n代码结果\n查看根目录下执行，即可查看自己创建的包\nlerna list\n\n创建/导入项目注意：导入和创建项目不会被计入lerna的包，即lerna list不会记录创建或导入的项目\n全新的项目可以直接cd packages去对应的包下创建文件夹npm init -y等等，或者直接使用脚手架npx create-react-app main-app创建新项目\n已有的项目使用如下命令\nlerna import &lt;project url&gt;\n\n装包建立相互依赖的包之间的软连接并安装其他的依赖, 默认是npm i,因为我们指定过yarn，因此执行yarn install,会把所有包的依赖安装到根node_modules.\nlerna bootstrap\n\n向项目中添加依赖lerna add &lt;dependencies&gt; --scope=&lt;project&gt;\n\n\n\n组织Workspaces通常起项目的时候，最好能在根目录配置对应的命令，这里可以参考yarn workspaces的组织方法\n根目录下start命令意味着执行package.json里name为react-code-demo的start命令\n根目录package.json\n&#123;  \"name\": \"root\",  \"private\": true,  \"workspaces\": [    \"packages/*\"  ],  \"devDependencies\": &#123;    \"lerna\": \"^5.5.0\"  &#125;,  \"scripts\": &#123;    \"start\": \"yarn workspace react-code-demo start\"  &#125;&#125;\n\n项目react-code-demo的package.json\n&#123;  \"name\": \"react-code-demo\",  \"version\": \"0.1.0\",  \"private\": true,  \"scripts\": &#123;    \"start\": \"react-scripts start\",    \"build\": \"react-scripts build\",    \"test\": \"react-scripts test\",    \"eject\": \"react-scripts eject\"  &#125;,  ... // 下面还有不展示了\n\n\n动态更新修改包对应的代码，无需重启，无需复制，由于对应包lerna都是软链到根目录node_modules，修改包信息会直接同步到顶层node_modules，因此刷新即可生效\n发布lerna提供两个指令\nlerna changed\n\n列出下次发版lerna publish要更新的包。\n原理： 需要先git add,git commit 提交。 然后内部会运行git diff --name-only v版本号，搜集改动的包，就是下次要发布的，并不是网上人说的所有包都是同一个版全发布\nlerna publish\n\n首先对应的package.json要配置publishConfig，属于npm相关内容不再赘述，执行命令\n会打tag，上传git,上传npm\n\n基本使用如下，开发者可以根据需求自定义命令，如清理node_modules、是否需要依据package.lock.json等安装，五花八门，等发现更有价值的持续更新。\n参考链接：\nLerna 中文详解教程：https://juejin.cn/post/6844903856153821198#heading-21lerna.js：monorepos项目管理模式简单实践: https://developer.aliyun.com/article/1007301\n\n","categories":["工程化"],"tags":["工程化","包管理工具"]},{"title":"react-hook-form解决方案","url":"/2022/10/18/react-hook-form%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","content":"选择的原因公司本身使用reduxForm处理表单，也讨论过使用antd的表单，思考许久有以下问题:\nreduxForm\n不排除我对reduxForm理解不够深\n\nreduxForm已经停止维护，表单过重，打包体积过大(24kb)，react-hook-form 8k\n\nreduxForm处理联动逻辑比较麻烦，没有一个可靠的form实例\n\nreduxForm联动改变数值不触发校验，手动触发校验方式比较hack(针对每个Form组件拿到实例手动触发onBlur校验)，其次校验render时机不正确，导致错误文案没法展示，项目中使用setTimeout解决\n\nreduxForm文档比较难读，对Typescript支持不友好\n\nreduxForm是采用高阶组件，对逻辑复杂的表单的onChange会有性能问题(卡顿，输不了值)，目前已经有FormComponent出现此问题\n\n\nantd\n\nantd封装了一个完整的解决方案，底层使用rc-field-form，假如我们在rc-field-form到Form这个过程需要自定义业务，难以实现，并且有很多不需要的功能\n\nantd的表单再去封装动态表单难以实现，例如基于antd的Form去封装一个ant-design-pro的ProForm成本会激增\n\nantd的功能如果没有你想要的，无法去表单内部实现，只能通过其他方式，例如: reduxForm会对表单组件传递dirty判断数据是否被修改、valid判断校验是否通过(不触发render的情况下)\n\nantd是属于另一个ui库，与我们初始的ui选型不一致，无法单独引入Form，antd的样式采用module css的方式，与material-ui的css in js的方式相违背，未来在主题上会出现很多问题\n\n\n实现的目标静态表单表单数据都是以组件形式自己编写\n&lt;Form&gt;    &lt;Form.Item name=\"xx\"&gt;        &lt;FormComponent /&gt;    &lt;/Form.Item&gt;&lt;/Form&gt;\n\n目标: \n借鉴antd，保留原项目reduxForm中好的东西，剔除antd不需要的功能，每一步流程都可以根据业务自定义\n对项目的Form表单实现统一校验、统一联动校验、统一/自定义样式布局、类似于antd中常用的基础功能\n保留一定的可扩展性未来支持骨架屏，处理异步逻辑等等\n动态表单表单数据以JSON schema的格式配置，统一渲染\nconst formField = [    &#123;        type: 'Input'        name: 'xxx',        label: 'xxx',        property: &#123;            ...// 属性        &#125;    &#125;]&lt;HookForm formField=&#123;formField&#125; /&gt;\n\n动态表单解决的问题:\n\nFormComponent过多且布局较为统一\n\n表单数据以JSON Schema的形式存储在后端\n\n\n目标: \n功能上支持自定义校验、自定义组件配置、联动逻辑、表单动态的props传递\n静态表单实现方式流程\nForm\n处理用户对表单的全局监听，以及hook-form中提供的内置方法\n\n\n\n处理contextValue，需要传递给Form.Item的全部放在contextValue下\n\n\n\n根据用户传递的ref，创建实例，抛出实例方法\n\n\nForm.Item\n渲染FormComponent时对每一个FormComponent增加默认样式(FieldWrap)\n\n\n\n针对没有提供name的FormComponent只渲染样式，数据不受hook-form控制\n\n为用户提供单个FormComponent的监听(直接在Form.Item上传递onChange)\n\n处理表单校验(默认校验、自定义校验)，提供自定义校验会覆盖默认校验\n\n\n\n\n讲hook-form保存的value传递到表单组件用于受控，将改变hook-form``FormComponent的onChange传递到对应表单(即受控组件常用的value和onChange)\n\n动态表单实现方式流程\nHookForm\nonTrigger作为回调传递给FieldRender的onChange, 针对表单的每个onChange会判断是否满足联动逻辑\nFieldRender\n处理每个表单的统一校验，针对单个FormComponent的用户自定义校验\n\n获取FormComponent的props, 包括了JSON schema中property属性下的、开发者privateProps以及全局的publicProps\n\n\n\n动态表单validate.ts校验相关\n\n自定义表单组件编写方式统一规定受控组件, 使用TypeScript编写\n\nonChange是hook-form的onChange, 用于改变表单的值\n\nvalue是hook-form数据池中的数据\n\n\n\nFieldMap\nvalidate.ts\nTypeScript支持\n对应自定义的FormComponent的类型\n\n\n\n对应Form实例Type\n\n\n不足与改进\n由于二级表单形式五花八门，不支持二级表单，目前也没想好怎么支持\n\n默认的表单数据的类型应该作为泛型传入，而不是内置HookFormData传入，这样导致submit返回的类型与外部定义的类型不兼容，需要类型断言。写完后才发现，看了antd的Form也是那么做的，但是改动量过大\n\n假如Button的按钮提交根据是否校验通过和是否修改过默认表单数据来判断是否disable，目前只能render在&lt;Form&gt;&lt;/Form&gt;组件的最后，不能自定义渲染位置。reduxForm是采用高阶组件的模式，会渲染全表单，与hook-form设计思想违背，hook-form将每个FormComponent与自身数据池隔离提升性能。目前也没有想到最优解\n\ndefaultFormData可能是异步的，目前必须在无数据的时候不渲染Form，不然默认值设置不上去， 如下：\n// 假如 asyncDefaultFormData 是异步获取的!asyncDefaultFormData ? null : &lt;Form defaultFormData=&#123;asyncDefaultFormData&#125; /&gt;\n\n","categories":["工程化"],"tags":["React","工程化","Form"]},{"title":"setState到底是同步还是异步的","url":"/2020/07/25/setState/","content":"setState同步还是异步\nsetState有时表现出异步,有时表现出同步,在合成事件和钩子函数中表现异步\nsetState批量更新优化是建立在合成事件和钩子函数之上的,在原生事件和setTimeout中不会发生异步.(顺序为setState =&gt; 钩子函数 =&gt; 合并更新状态)\n\n\n\n合成事件\nReact通过事件冒泡,将事件冒泡到document上面,再统一分发给中间层SyntheticEvent去执行事件\n\n钩子函数\n钩子函数指生命周期的钩子\n\n\n合成事件和钩子函数参考文档\nsetState之后到底发生了什么setState有两个注意事项:官网提供:\n\n出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用\n因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态add() &#123;    this.setState(&#123;count:count + 1&#125;)    this.setState(&#123;count:count + 1&#125;)&#125;add()\n\n\n上述连续两次在点击事件调用setState图例执行顺序第一步\n首先调用实例的updater上的enqueueSetState\n目的是让setState入列ReactComponent.prototype.setState = function (partialState, callback) &#123;  //  将setState事务放进队列中  this.updater.enqueueSetState(this, partialState);  if (callback) &#123;      this.updater.enqueueCallback(this, callback, 'setState');  &#125;&#125;;\n第二步\n将更新状态的组件也放入队列中\n将新的state放进数组里 \n用enqueueUpdate来处理将要更新的实例对象\n\n目前达到的效果\nsetState在队列中\n在这个setState执行过程里 我们将state放入了一个队列 将要更新的组件也放入了一个队列 enqueueSetState: function (publicInstance, partialState) &#123;  // 获取当前组件的instancevar internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState'); // 将要更新的state放入一个数组里 var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);queue.push(partialState);//  将要更新的component instance也放在一个队列里enqueueUpdate(internalInstance);  &#125;\n\n\n\n\n第三步\n调用enqueueUpdate执行更新操作,如果处在更新,那么只是将组件放入脏组件队列中function enqueueUpdate(component) &#123;  // 如果没有处于批量创建/更新组件的阶段，则处理update state事务  if (!batchingStrategy.isBatchingUpdates) &#123;    batchingStrategy.batchedUpdates(enqueueUpdate, component);    return;  &#125;  // 如果正处于批量创建/更新组件的过程，将当前的组件放在dirtyComponents数组中  dirtyComponents.push(component);&#125;\n这个更新函数,接收一个组件的实例 首先判断是否处于更新阶段 如果不是 那么执行更新 如果处在更新阶段 那么我将组件的实例push到队列中 等待更新这个函数也说明了setState是一个异步的过程，它会集齐一批需要更新的组件然后一起更新\n\n第三步拓展——批量更新策略(batchingStrategy)\n第三步中,如果不处在更新状态,就执行batchingStrategy.batchedUpdates(enqueueUpdate,component)\n\n批量更新策略所在的对象\nbatchedUpdates做了个判断,如果我处在更新状态,那么组件入列, 否则开启更新事务var ReactDefaultBatchingStrategy = &#123;  // 用于标记当前是否出于批量更新  isBatchingUpdates: false,  // 当调用这个方法时，正式开始批量更新  batchedUpdates: function (callback, a, b, c, d, e) &#123;    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;    ReactDefaultBatchingStrategy.isBatchingUpdates = true;// 如果当前事务正在更新过程中，则调用enqueueUpdate    if (alreadyBatchingUpdates) &#123;      return callback(a, b, c, d, e);    &#125; else &#123;    // 否则执行更新事务      return transaction.perform(callback, null, a, b, c, d, e);    &#125;  &#125;&#125;;\n\n\n\n第三步拓展——事务\n所谓事务,就是把函数做一层包装,开始是做一些操作,结束时做一些操作\n\n下面是一个简单的事务例子\nvar Transaction = require('./Transaction');// 我们自己定义的 Transactionvar MyTransaction = function() &#123;  // do sth.&#125;;Object.assign(MyTransaction.prototype, Transaction.Mixin, &#123;  getTransactionWrappers: function() &#123;    return [&#123;      initialize: function() &#123;        console.log('before method perform');      &#125;,      close: function() &#123;        console.log('after method perform');      &#125;    &#125;];  &#125;;&#125;);var transaction = new MyTransaction();var testMethod = function() &#123;  console.log('test');&#125;transaction.perform(testMethod);// before method perform// test// after method perform\n\n\nReact源码的事务中有两个事务RESET_BATCHED_UPDATES(用于重置更新状态) FLUSH_BATCHED_UPDATES(再发起一个dom的批量更新,包括渲染和虚拟dom比对等等)\n\nFLUSH_BATCHED_UPDATES这个事务的目的在于循环所有更新组件,执行update,调用组件更新的生命周期等等\nvar RESET_BATCHED_UPDATES = &#123;  initialize: emptyFunction,  close: function () &#123;    ReactDefaultBatchingStrategy.isBatchingUpdates = false;  &#125;&#125;;var FLUSH_BATCHED_UPDATES = &#123;  initialize: emptyFunction,  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)&#125;;\n\n\n\n\n总结\nsetState第一步:将state塞入数组,将组件交给更新队列\nsetState第二步:更新队列进行更新,如果更新队列正在更新,将组件塞入脏组件队列.否则执行批量更新策略\nsetState第三步:批量更新策略判断是否处在批量更新状态,如果正在更新,那么将更新组件塞入脏组件队列,否则把脏组件所有组件拿出来开启事务更新\nsetState第四步,批量更新结束事务,在事务结束前,会调用FLUSH_BATCHED_UPDATES计算最新的state和props.然后关闭事务\n然后React可以拿到最新的state和props进行虚拟dom比对,虚拟dom比对完之后,会去渲染组件,此时如果有shouldUpdate,会进行一个是否渲染组件的判断\n\n为什么setTimeout下setState是同步的\n关键在于批量更新策略什么时候开启的\nReact开启批量更新策略有两个位置,一个是钩子函数,一个是合成事件,可以将钩子函数和合成事件理解为一个大的事务,当触发时,React会开启批量更新策略.而当执行setTimeout的时候,大事务已经关闭,批量更新策略已经重置为false\n实际上,调用setState触发了两个批量更新事务,相当于同步更新的过程了.\n\n面试问答\n问: setState过后到底发生了什么?\n答: 将组件交给更新队列,将state塞入数组,然后执行队列更新方法,如果队列正在更新,组件就塞入脏组件,否则执行批量更新策略, 批量更新策略会去判断是否正在批量更新,如果正在更新,会把队列放入脏组件,否则循环脏组件队列开启事务执行批量更新,然后在事务结束前计算最新state和props,React拿到他们去进行虚拟dom比对,组件渲染,判断shouldUpdate,进行更新.更新完执行componentDidUpdate…\n\nReact - setState源码分析（小白可读）揭密React setStatereact源码分析之-setState是异步还是同步？\n","categories":["React"],"tags":["前端","React"]},{"title":"从源码分析diff算法","url":"/2022/06/18/%E4%BB%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90diff%E7%AE%97%E6%B3%95/","content":"从源码分析diff算法\n以下需要建立在对react理念和react render阶段有一定理解的基础上\n\ndiff算法发生在beginWork函数中\n满足current !== null时进行diff(为null时意味着本次是mount阶段)，mount阶段beginWork生成的子Fiber均被打上Placement的标记并存储在flags属性上(前几个版本存在effectTag上)\ndiff算法本质是将current树上的fiber与组件update后返回的jsx进行对比，生成打好flags的子Fiber节点\n入口以div举例，beginWork会根据 当前workInProgress的tag(即上一次beginWork生成好的子Fiber节点) 来判断更新的类型, div属于HostComponent将执行updateHostComponent\n\n比较对象以以下代码为例，workInProgress为下图红框时\n\n由下图可以看出，调用reconcileChildren传入的nextChildren是当前workInProgress的 children, 以我们的例子来说就是div下的jsx\n注意点：div下的jsx并非单一节点时，nextChildren为数组类型，因此diff算法可能是链表与数组间的比较\n\n下图可知，比较对象是current.child与上面说的nextChildren的比较\n\ndiff流程由下图可知，diff主要分为jsx返回的是单节点的diff和jsx返回的是多节点的diff\n单节点中，至于其他的关于Portal、TextNode都比较好理解，简单概述一下\n\nPortal的更新和单节点的diff算法很像\n\n如果是文本节点，则将current.child的比较节点全部删除(原因是因为beginWork一次只生成一个child节点), 并基于此current.child重新克隆一个fiber节点\n\n\n\njsx返回的是单节点的diff下图红框表示节点是更新的节点, 棕色框表示节点是新增的节点\n\n红框意味着刚进来有值，说明当前current.child处在同层级\n\n棕框意味着当前界面上的节点不存在，本次更新或者挂载的是一个全新的节点，因此要为当前全新的节点创建一个fiber并返回\n\n\n\n主要关注红框的部分, 核心逻辑如下\n\nkey不相同，把当前current.child(即当前current树上进行diff的节点)删除，将指针移到current.child的兄弟节点进行比较\n\n注意点：key不相同不会把所有兄弟节点都删除，只会删除当前比较的，如果兄弟节点key相同还是会有复用的可能性\n\n\nkey相同，比较elementType是否相同，如果相同，直接基于当前current.child创建一个fiber\n\n注意如果复用这个fiber节点的child是和当前的current.child完全一样，可以减少渲染\n\n\nkey相同，如果type不相同，要把current.child及其的兄弟节点一并删除\n\n\n看如下代码，React不会复用更新前的div，而是把两个全都删了，重新创建\n// 更新前&lt;p key=\"1\"&gt;1&lt;/p&gt;&lt;div key=\"1\"&gt;1&lt;/div&gt;// 更新后&lt;div key=\"1\"&gt;1&lt;/div&gt;\n\n\njsx返回的是多节点的diff(Array, Iterator)第一轮遍历终止条件\noldFiber遍历完或者newChildren遍历完或者说当前diff的两个节点key不相同\n\n如果key相同，继续判断，调用updateElement，方法比较简单\n\n如果type不相同那么不能复用，这个时候会基于当前的newFiber创建fiber, 并将当前的oldFiber删除，继续遍历\n如果type相同，那么可以复用\n\n\n\n\n第二轮遍历第二轮遍历是会带着第一轮遍历的结果去进行遍历，结果有以下情况：\n下图先解释比较容易得两种情况：\n\nnewIdx === newChildren.length意味着新节点遍历完，那么直接把剩余没遍历的oldFiber删掉即可\n\noldFiber === null意味着旧的节点遍历完了，那么遍历剩余的新节点依次创建Fiber即可\n\n\n\n下图解释最复杂的情况，能进下图的位置说明newChildren和oldFiber都没遍历完\n\nmapRemainingChildren这个方法是为了在O(1)复杂度快速找到对应的current节点，因此把key或者索引index作为key，current节点作为value存在map中\n\n遍历剩下的newFiber，先找key一样的，没有key就找同位置的，为了找到移动的节点，调用updateElement——能复用就复用，不能复用就自己创建\n\n\n\nlastPlacedIndex详细解释(精髓)lastPlacedIndex这个索引解释——新创建的Fiber节点在dom中要插入的位置\n\n如果当前节点没有被复用，是全新创建的话，那么这个值不变，并打上Placement\n\n如果当前节点被复用了，这个值是返回Max{oldIndex, lastPlacedIndex}\n\n如果这个节点被复用了，oldIndex &lt; lastPlacedIndex需要移动\n\n\n\n多节点diff总结\n第一次遍历用新旧同层判断key是否相同，不相同跳出，遍历完跳出\n\n第二次遍历\n 2.1 oldFiber遍历完，创建新节点。newChildren遍历完删除多的oldFiber\n 2.2 两个都没遍历完，将剩余的oldFiber存成map。遍历newChildren，如果可以找到可以复用，判断oldIndex &lt; lastPlacedIndex，标记Placement。并将lastPlacedIndex设置为oldFiber里当前遍历到的！！！最后一个可复用的节点\n\n\n","categories":["React"],"tags":["前端","React","源码系列"]},{"title":"发票匹配(待对账明细匹配)","url":"/2022/05/12/%E5%8F%91%E7%A5%A8%E5%8C%B9%E9%85%8D%E2%80%94%E2%80%94%E6%89%8B%E5%8A%A8%E5%BD%95%E5%85%A5%E5%BE%85%E5%AF%B9%E8%B4%A6%E6%98%8E%E7%BB%86%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/","content":"交互图\n与单配发票的区别\n\n\n单配发票\n发票配待对账明细\n\n\n\n首先做准入性校验\n不需要做准入性校验(发票采集已做)\n\n\n优先后端自动匹配\n用户选择明细匹配，提交校验\n\n\n发票：单据明细 = 1:1\n发票：单据明细 = n:n\n\n\n\n\n整体设计组件设计\n对应的组件结构图\n流程设计与 发票匹配2.0技术设计 的流程中的手动匹配一致(去掉容差部分)，区别在于容差非前端计算\n数据结构设计原数据结构\n// 单张发票对象 &#123;       invoiceItems: [&#123;              // 单张发票匹配的单据              sourceItems: [&#123;                       invoiceAmount: ,                      invoicedQuantity: , // 数量                      totalAmountIncludedTax: , // 含税金额                      totalAmountExcludedTax: , // 未税金额                       totalTax: ,// 税额                       ...             &#125;],      ]，    // 发票明细          status，    // 发票验真状态          errorCode, // 准入性校验结果          matchStatus，    // 匹配结果         matchResult， // 容差匹配结果          matchOffset， // 模糊匹配后端返回容量          leftCapacity: &#123;  // 人工介入的剩余容量                 alert， // 是否需要人工介入                 ... // 剩下的就是容量字段          &#125;，&#125;]&#125;// 全局数据管理referenceType: 匹配模式globalInvoice: 匹配的发票列表globalSourceItems: 全局的单据globalMatchedSourceItems: 全局匹配的单据globalUnMatchedSourceItems: 全局未匹配的单据globalMatchedSourceItemsMap: 全局匹配的单据code与对应金额数量映射表globalConfirmList: 全局待确认的映射表\n\n上一个版本发票明细：单据明细为多对多，但是发票明细只能存在于同一张发票中\n这个版本需要修改数据结构，改成匹配关系更为明确的方式，要支持跨发票的发票明细多对多(即发票明细：单据明细 = n:n 并且 发票：单据明细 = n:n)\n数据流设计与原发票基本一致，参考 发票匹配2.0技术设计 中的数据流设计，区别在于增加了全局的globalMatchGroupList\n假如是发票与单据明细匹配， 那么groupId挂在发票对象上，如果是发票明细与单据明细匹配，那么groupId挂在发票明细对象上\n一条发票明细只能存在于一个匹配组，对于未验真发票来说，一张发票也只能存在一个匹配组，并且对于未验真发票来说不能单独匹配\n现有数据结构\n// 单张发票对象 &#123;       invoiceItems: [&#123;              // 单张发票匹配的单据          groupId, // 多对多的话针对的是匹配组    ],    // 发票明细          status,    // 发票验真状态          errorCode, // 准入性校验结果          matchStatus，    // 匹配结果         matchResult， // 容差匹配结果          matchOffset， // 模糊匹配后端返回容量          groupId, // 未验真发票匹配的单据(未验真发票没有明细)    leftCapacity: &#123;  // 人工介入的剩余容量                 alert， // 是否需要人工介入                 ... // 剩下的就是容量字段          &#125;，&#125;]&#125;// globalMatchGroupList&#123;    matchGroupList: &#123;        1: &#123;            invoiceItems: [],            sourceItems: [],            invoiceCode: 12121212        &#125;,        2: &#123;            invoiceItems: [],            sourceItems: [],            invoiceCode: 12121212        &#125;    &#125;&#125;// 全局数据管理referenceType: 匹配模式globalInvoice: 匹配的发票列表globalSourceItems: 全局的单据globalMatchedSourceItems: 全局匹配的单据globalUnMatchedSourceItems: 全局未匹配的单据globalMatchedSourceItemsMap: 全局匹配的单据code与对应金额数量映射表globalConfirmList: 全局待确认的映射表globalMatchGroupList: 全局匹配的匹配组\n","categories":["业务"],"tags":["业务","前端"]},{"title":"发票匹配2.0技术设计","url":"/2022/02/21/%E5%85%AC%E5%8F%B8%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1-%E5%8F%91%E7%A5%A8%E5%8C%B9%E9%85%8D%E9%87%8D%E6%9E%84/","content":"整体设计组件结构图\n父： 发票列表页 InvoiceListModal\n父： 发票明细匹配情况(未匹配 和 已匹配) InvoiceMatch\n子：NeedManualMatchTable（未匹配列表）\n子：InvoiceMatchedTable （已匹配列表）\n\n\n父：手动匹配 InvoiceManualMatch \n子：SoureceManualMatchTable（单据明细列表）\n子：InvoiceManualMatchTable （发票明细列表）\n\n\n父： 用户待确认明细 InvoiceUniqueness\n子：ConfirmManualMatchTable （待确认单据列表）\n子：InvoiceManualMatchTable （待确认发票明细列表）\n\n\n\n\n\n\n组件数据交互流图虚线代表数据传输 实线代表实际交互流程方框代表组件(对应上图组件) / 数据结构菱形代表数据处理 / 用户动作 / 判断条件气泡框代表解释主要设计思想：\n\n所有数据初始化过后不再进行修改，直接有用的参数全部挂在发票对象上\n对应发票匹配的单据挂发票上，发票明细匹配的单据挂发票明细上，多对多匹配的用groupId确认分组\n可逆操作的数据全都使用备份\n共同数据全部使用全局数据管理\n容差在需要的顶层配置好，把对应配置项传下去根据配置数据结构直接渲染\n\n\n发票redux数据模型设计核心是高阶reducer的复用以及业务action的拆分\n\n高阶reducer好处1：同样的单据集的处理不用处理多套\n高阶reducer好处2：对于备份的发票和单据，也可以复用对应的处理方式(useReducer)\naction拆分好处：action不但可以用于生成新的全局state，还可以用于普通单据的增删改\n\n\n容差设计顶层根据配置返回如下结构&#123;      [MONEY_MATCH_SETTING.AMOUNT_INCLUDED_TAX]: &#123;           isOpen, // 存是否被打开了           usedOffset, // 发票已经被占用的容差, 这里的可用容差都是针对发票的           isStrength, // 强校验还是弱校验           isExceed, // 是否超出容差值           tailing, // 设置的容差值      &#125; &#125;\n\n后续对容差的操作直接通过 invoiceUtil.js 下对应的容差方法修改\n所有操作都是基于此数据结构（计算和渲染），如有可逆操作将此结构备份\n\n强弱校验设计强弱校验相关的全部基于以下二进制进行操作\nexport const NoStatus = /*                    */ 0b00000000000000000000000000; // 不校验export const IgnoreStatus = /*                */ 0b00000000000000000000000001; // 校验通过export const WarningStatus = /*               */ 0b00000000000000000000000010; // 弱通过export const ForbiddenStatus = /*             */ 0b00000000000000000000000100; // 强通过\n\n以强校验举例\n\n初始化为 NoStatus，如果遇到了某强校验， 则使用 NoStatus |  ForbiddenStatus\n判断某校验是否为强校验(假设此变量x的二进制为ForbiddenStatus), 则：(x &amp; ForbiddenStatus) !== NoStatus  代表变量x是强校验\n通常后端会返回对应好字段 &quot;FORBIDDEN&quot;、&quot;WARNING&quot;、&quot;IGNORE&quot;，invoiceUtil做好映射如下：export const resultStringMapStatus = &#123;    'FORBIDDEN': ForbiddenStatus,    'WARNING': WarningStatus,    'IGNORE': IgnoreStatus,&#125;;\n针对匹配错误相关的映射，invoiceUtil文件下做好映射如下：[errorCode/matchStatus]: &#123;  text: '错误提示文字',  status: ForbiddenStatus,&#125;,\n\n\n\n测试前端对测试的减负点：\n现容差整体顶层配置，只需要详细测一个纬度即可，其他纬度挑一个点测\n发票手动匹配流程只需要测一个纬度就行，其他纬度挑一个情况测\n抬头联动的测试，只需要测 有强有弱/无强有弱/无强无弱 三种情况，分别是 红/黄/白，现逻辑都是有红则红，没红有黄则黄， 都没有则白\n\n产品产品设计对前端的影响点：\n不要让前端在发票列表页计算容差，影响性能（有些发票相关信息未必是发票上直接获取，需要去累加发票明细，如数量）。目前卡死在发票明细匹配情况页面，\n减少跨发票的操作（所有操作都是A发票的，操作完修改另一张发票匹配的相关数据），实现成本极大\n设计时减少跨级操作，例如：发票列表页直接跳过发票明细匹配情况页面，直接进入手动匹配页面，属于比较特殊的代码（目前有且只有未验真可以有如此操作），会让前端代码变得复杂难以维护\n尽可能按照组件结构图的流程走，匹配流程不要再整体的匹配过程中插入新的页面\n\n","categories":["业务"],"tags":["业务","前端"]},{"title":"剑指offer(持续更新)","url":"/2022/06/09/%E5%89%91%E6%8C%87offer/","content":"Day1——栈与队列（简单）剑指 Offer 09. 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1)\n示例\n\nTIP 输入\n&gt;[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]&gt;[[],[],[5],[2],[],[]]\n输出: [null,-1,null,null,5,2]\n\n题解解题关键：了解栈和队列的区别，两个栈模拟，一个栈用于进，一个栈用于出\n栈和队列的区别：\n栈：先进后出(只能一端插入和删除)\n队列：先进先出(只能一端插入，另一端删除)\nvar CQueue = function(quene = []) &#123;   this.instack = []   this.outstack = []&#125;;/**  * @param &#123;number&#125; value * @return &#123;void&#125; */CQueue.prototype.appendTail = function(value) &#123;    this.instack.push(value)&#125;;/** * @return &#123;number&#125; */CQueue.prototype.deleteHead = function() &#123;    // 删除的时候先用另一个栈来模拟队列的另一端    if(!this.outstack.length)&#123;        if(!this.instack.length)&#123; // 没有元素            return -1        &#125;        else&#123;            while(this.instack.length)&#123;                this.outstack.push(this.instack.pop())            &#125;        &#125;    &#125;    return this.outstack.pop()&#125;;/** * Your CQueue object will be instantiated and called as such: * var obj = new CQueue() * obj.appendTail(value) * var param_2 = obj.deleteHead() */\n\n\n\n\n剑指 Offer 30. 包含min函数的栈示例\n\nTIP 输入\n&gt;[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]&gt;[],[-2],[0],[-3],[],[],[],[]]\n输出: [null,null,null,null,-3,null,0,-2]解释: MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; 返回 -3.minStack.pop(); minStack.top(); –&gt; 返回 0.minStack.getMin(); –&gt; 返回 -2.\n\n题解解题关键：创建辅助栈minStack, 与栈空间保持同步操作, 空间换时间\n/** * initialize your data structure here. */var MinStack = function() &#123;    this.inStack = []    this.minStack = [Infinity]&#125;;/**  * @param &#123;number&#125; x * @return &#123;void&#125; */MinStack.prototype.push = function(x) &#123;    this.inStack.push(x)    this.minStack.push(Math.min(this.minStack[this.minStack.length - 1], x))&#125;;/** * @return &#123;void&#125; */MinStack.prototype.pop = function() &#123;    this.inStack.pop()    this.minStack.pop()&#125;;/** * @return &#123;number&#125; */MinStack.prototype.top = function() &#123;    return this.inStack[this.inStack.length-1]&#125;;/** * @return &#123;number&#125; */MinStack.prototype.min = function() &#123;    return this.minStack[this.minStack.length - 1]&#125;;/** * Your MinStack object will be instantiated and called as such: * var obj = new MinStack() * obj.push(x) * obj.pop() * var param_3 = obj.top() * var param_4 = obj.min() */\n\nDay2——链表（简单）剑指 Offer 06. 从尾到头打印链表示例\n\nTIP 输入\n&gt;head &#x3D; [1,3,2]\n输出: [2,3,1]\n\n题解方法：定义一个数组，一边遍历一边往数组前面添加\nvar reversePrint = function(head) &#123;    let number = [];    let node = head    while(node)&#123;        number.unshift(node.val)        node = node.next    &#125;    return number&#125;;\n\n\n剑指 Offer 24. 反转链表示例\n\nTIP 输入\n&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL\n输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL\n\n题解方法：定义两个指针，一前一后，一边遍历一边翻转注意点：注意后指针指向前指针时需要一个暂存指针指向下一次循环的指针\nvar reverseList = function(head) &#123;    if(!head) return head    let prev = null    let cur = head    while(cur)&#123;        let temp = cur.next        cur.next = prev        prev = cur         cur = temp    &#125;    return prev&#125;;\n\n剑指 Offer 35. 复杂链表的复制示例\n\nTIP 输入\n&gt;head &#x3D; [[7,null],[13,0],[11,4],[10,2],[1,0]]\n输出:[[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n题解陷阱：复制的时候未必所有的节点都生成了新的，要避免指到旧的\n方法：\n\nhash表，第一次遍历存好最新的，遍历hash表设置random\n遍历旧链表，复制一份到每个节点的后面(不赋值random)，新节点的next指向原来旧节点的下一个节点，这样可以减少空间(空间复杂度O(1))\n\n/** * // Definition for a Node. * function Node(val, next, random) &#123; *    this.val = val; *    this.next = next; *    this.random = random; * &#125;; */// 方法一: hash表var copyRandomList = function(head) &#123;    if(!head) return null    let map = new Map()    let node = head;    while(node)&#123;        map.set(node, new Node(node.val))        node = node.next    &#125;    node = head    while(node)&#123;        map.get(node).next = node.next ? map.get(node.next) : null        map.get(node).random = node.random ? map.get(node.random) : null        node = node.next    &#125;    return map.get(head)&#125;// 方法二：后继节点var copyRandomList = function(head)&#123;    if(!head) return null    let node = head;    while(node)&#123;        let nodeNew = new Node(node.val, node.next)        node.next = nodeNew        node = nodeNew.next    &#125;    node = head;    while(node)&#123;        let nodeNew = node.next;        nodeNew.random = node.random ? node.random.next ： null；    &#125;    node = head    const returnNode = node.next    while(node)&#123;        nodeNew.next = nodeNew.next ？ nodeNew.next.next : null        node = node.next    &#125;    return returnNode;&#125;\n\nDay3——字符串（简单）剑指 Offer 05. 替换空格示例\n\nTIP 输入\n&gt;s &#x3D; &quot;We are happy.&quot;\n输出:”We%20are%20happy.”\n\n题解直接调用现成方法即可\n/** * @param &#123;string&#125; s * @return &#123;string&#125; */var replaceSpace = function(s) &#123;    return s.replaceAll(' ', '%20')&#125;;\n\n剑指 Offer 58 - II. 左旋转字符串示例\n\nTIP 输入\n&gt;s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2\n输出: “cdefgab”\n\n题解方法一： 运用取余的特性去解 (遍历到的第i项 + 第n位开始翻转) / 字符串长度 就是对应位置\n方法二： 直接切割成俩数组, 倒转拼接\n// 方法一：var reverseLeftWords = function(s, n) &#123;    return Array.from(s).map((_v,i)=&gt;s[((i+n))%s.length]).join('')&#125;;// 方法二：var reverseLeftWords = function(s, n) &#123;    const left = s.slice(0, n)    const right = s.slice(n, s.length)    return right + left&#125;;\n\nDay4——查找算法（简单）Day4实在太简单了，稍微挑一个有技巧一点的\n剑指 Offer 53 - II. 0～n-1中缺失的数字示例\n\nTIP 输入\n&gt;[0,1,3]\n输出:2\n\n题解二分查找法\n\n左指针指向第一个，右指针指向最后一个，定义一个指针指向中间\n\n如果number[middle] === middle, 那么右边缺, 否则左边缺\n\n当跳出循环的时候, 左指针指向右区间第一个元素，右指针指向左区间最后一个元素, 即返回左指针\n\n\n/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var missingNumber = function(nums) &#123;    let i = 0;    let j = nums.length - 1    while(i &lt;= j)&#123;        let middle = Math.floor(i + (j - i) / 2)        if(number[middle] === middle)&#123;            i = middle + 1        &#125;        else&#123;            j = middle - 1        &#125;    &#125;    return i&#125;;\nDay5——查找算法（中等）剑指 Offer 04. 二维数组中的查找示例\n\nTIP 输入\n&gt;二维数组&gt;[ [1,   4,  7, 11, 15], [2,   5,  8, 12, 19], [3,   6,  9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]&gt;]&gt;target 5\n输出: true\n\n题解技巧：从右上角开始找，如果target小，找左边一列，target大，找下一行\nvar findNumberIn2DArray = function(matrix, target) &#123;    if(!matrix || !matrix.length || !matrix[0].length) &#123;        return false    &#125;    var line = 0;    var col = matrix[0].length - 1    while(line &lt;= matrix.length &amp;&amp; col &gt;= 0)&#123;        if(target &lt; matrix[line][col])&#123;            col--        &#125;        else if(target &gt; matrix[line][col])&#123;            line++        &#125;        else&#123;            return true        &#125;    &#125;    return false&#125;;\n\n剑指 Offer 50. 第一个只出现一次的字符示例\n\nTIP 输入\n&gt;s &#x3D; &quot;abaccdeff&quot;\n输出:’b’\n\n题解关键: 两次遍历，第一次用hash表存字符出现的次数，第二次如果次数为1直接返回\nvar firstUniqChar = function(s) &#123;    var map = new Map();    for(var i = 0;i &lt; s.length;i++)&#123;        const time = map.get(s[i]) || 0        map.set(s[i], time + 1)    &#125;    for(var i = 0;i &lt; s.length;i++)&#123;        if(map.get(s[i]) === 1) return s[i]    &#125;    return \" \"&#125;\n\nDay6——搜索与回溯算法（简单）三个题目长得一样的，挑一个讲\n剑指 Offer 32 - III. 从上到下打印二叉树 III之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印\n示例\n\nTIP 输入\n&gt;[3,9,20,null,null,15,7]\n输出:[  [3],  [20,9],  [15,7]]\n\n题解关键点：\n\n广度优先(需要一个队列)\n一正一反，push结果的时候根据是否需要倒序输出决定用push还是unshift\n\nvar levelOrder = function(root) &#123;    if(!root) return [];    var quene = [[root]];    var res = [];    var isLeft = 1; // 奇数表示正序，偶数表示倒序    while(quene.length)&#123;        const level = quene.shift();        const levelRes = [];        const levelQuene = [];        level.forEach(item =&gt; &#123;            if(item.left) &#123;                levelQuene.push(item.left)            &#125;            if(item.right) &#123;                levelQuene.push(item.right)            &#125;            if(isLeft % 2)&#123;                levelRes.push(item.val)            &#125;else&#123;                levelRes.unshift(item.val)            &#125;        &#125;)        isLeft++        if(levelQuene.length)&#123;            quene.push(levelQuene)        &#125;        if(levelRes.length)&#123;            res.push(levelRes)        &#125;    &#125;    return res&#125;\n\nDay7——搜索与回溯算法二（简单）剑指 Offer 26. 树的子结构(判断子树)示例例如:给定的树 A:\n 3\n\n/ \\   4   5\n  / \\\n 1   2\n给定的树 B：\n   4 \n  /\n 1\n返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。\n\n\nTIP 输入\n&gt;A &#x3D; [1,2,3], B &#x3D; [3,1]\n输出:false\n\n题解解题关键：\n\n深度遍历父树，遇到val相同的，就有可能是子树，依次比较父树和子树的每个节点\n\n递归判断相等时，如果B没有了，说明已经匹配完成了，为true。如果A没有了，说明越过A树，为false，如果val值不一样，那么匹配失败，false。\n\n\nvar isSubStructure = function(A, B) &#123;    if(!A || !B) return false;    return isSameTree(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B)&#125;function isSameTree(A, B)&#123;    if(!B)&#123;        return true    &#125;    if(!A)&#123;        return false    &#125;    if(A.val !== B.val)&#123;        return false    &#125;    return isSameTree(A.left, B) &amp;&amp; isSameTree(A.right, B)&#125;\n\n剑指 Offer 27. 二叉树的镜像示例请完成一个函数，输入一个二叉树，该函数输出它的镜像。\n\n\nTIP 输入\n&gt;root &#x3D; [4,2,7,1,3,6,9]\n输出: [4,7,2,9,6,3,1]\n\n题解解题思路：\n\n交换left和right，递归交换\n\nvar mirrorTree = function(root) &#123;    if(!root) return null;    var temp = root.left;    root.left = root.right;    root.right = temp;    if(root.left)&#123;        mirrorTree(root.left)    &#125;    if(root.right)&#123;        mirrorTree(root.right)    &#125;    return root;&#125;\n\n剑指 Offer 28. 对称的二叉树示例例如，二叉树 [1,2,2,3,4,4,3] 是对称的。    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n\n\nTIP 输入\n&gt;root &#x3D; [1,2,2,3,4,4,3]\n输出: true\n\n题解解题思路：\n用两个指针，一根往左走，另一根就往右走。一根往右走，另一根就往左走。\nvar isSymmetric = function(root) &#123;    return isMirror(root, root)&#125;function isMirror(p, q)&#123;    if(!p &amp;&amp; !q)&#123;        return true    &#125;    if(!p || !q)&#123;        return false    &#125;    return p.val === q.val &amp;&amp; isMirror(p.left, q.right) &amp;&amp; isMirror(p.right, q.left)&#125;\n\nDay8——动态规划（简单）剑指 Offer 10- I. 斐波那契数列示例写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：\nF(0) = 0,   F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.\n\n\nTIP 输入\n&gt;n &#x3D; 2\n输出:1\n\n题解不要用递归（暴掉的概率太大了）\n提供两种解法\n\n滚动数组解法\n\n\nvar fib = function(n) &#123;    const mod = 1000000007; // 防止过大    if(n &lt; 2)&#123;        return n    &#125;    let p = 0, q = 1, r = 1;    for(var i = 2;i &lt; n;i++)&#123;        p = q;        q = r;        r =(p + q) % mod;    &#125;    return r;&#125;\n\n\n矩阵快速幂\n 2.1 快速幂 O(logn) 的复杂度\n\na^n = a^(2^log2(n)), 因此计算O(logn)的复杂度次数即可得到高次幂的结果\n\n任意正整数的偶数n次幂，等于其(n/2)^2，基数则是n &gt;&gt; 2后的(n/2)^2 * (该数)\n2.2 矩阵的目的是得到递推关系\n得出我们的目的是求出矩阵的n次幂再乘以初始值\n\n\n\n\n// 矩阵乘法var mutiply = (a, b) =&gt; &#123;    var c = new Array(2).fill(0).map(() =&gt; new Array(2).fill(0))    for(var i = 0;i &lt; 2; i++)&#123;        for(var j = 0;j &lt; 2;j++)&#123;            c[i][j] = (BigInt(a[i][0]) * BigInt(b[0][j])) + (BigInt(a[i][1]) * BigInt(b[1][j]))        &#125;    &#125;    return c;&#125;// 快速幂算法，固定格式可以说var pow = (a, n) =&gt; &#123;    var ret = [[1, 0], [0, 1]]    while(n &gt; 0)&#123;        if((n &amp; 1) === 1)&#123; // 奇数            ret = mutiply(ret, a)        &#125;        n &gt;&gt; 1        a = mutiply(a, a)    &#125;&#125;var fib = function(n) &#123;    if (n &lt; 2) &#123;        return n;    &#125;    const mod = 1000000007; // 防止过大    const m = [[1, 1], [1, 0]]    const res = pow(m, n - 1) // 需要得出来的是[F(n), F(n - 1)]，因此F(n) = res[0][0] * F(1) + res[0][0] * F(0)    return BigInt(res[0][0]) % BigInt(mod)&#125;\n\n剑指 Offer 10- II. 青蛙跳台阶问题示例一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。\nTIP 输入\n&gt;n &#x3D; 2\n输出:2\n\n题解和上面的斐波那契数列一毛一样，唯一的区别就是F(0)和F(1)的初始值不一样\n// ...省略矩阵计算方法和快速幂算法var numWays = function(n) &#123;    if(n &lt; 2) return 1;    const m = [[1, 1], [1, 0]];    const res = pow(m, n - 1); // 需要得出来的是[F(n), F(n - 1)]，因此F(n) = res[0][0] * F(1) + res[0][0] * F(0)    const ways = (res[0][0] * 1 + res[0][0] * 1) % mod;    return ways;&#125;\n\n剑指 Offer 63. 股票的最大利润示例假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？\n\n\nTIP 输入\n&gt;[7,1,5,3,6,4]\n输出: 5\n\n题解方法：\n遍历每一天，每一天都在幻想买的是最低点，卖的是最高点即可\nvar maxProfit = function(prices) &#123;    if(!prices.length) return 0;    var minPrice = price[0];    var maxEarn = 0;    for(var i = 0; i &lt; prices.length;i++)&#123;        if(prices[i] &lt; minPrice)&#123;            minPrice = prices[i]        &#125;        if(prices[i] - minPrice &gt; maxEarn)&#123;            maxEarn = prices[i] - minPrice        &#125;    &#125;    return maxEarn &gt; 0 ? maxEarn : 0&#125;\n\nDay9——动态规划（中等）剑指 Offer 42. 连续子数组的最大和示例\n\nTIP 输入\n&gt;nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]\n输出:6解释：连续子数组 [4,-1,2,1] 的和最大，为 6。\n\n题解提供两种解法，均比较重要\n\n动态规划, 滚动数组\n\nMax{F(n - 1) + nums[i], nums[i]}\n\n\n\nvar maxSubArray = function(nums) &#123;    if(!nums.length) return 0;    var q = nums[0], max = nums[0]    for(var i = 1; i &lt; nums.length;i++)&#123;        // 看q是取之前的和还是说取本次这个数        q = Math.max(q + nums[i], nums[i]);        // 重新设置max        max = Math.max(q, nums[i])    &#125;    return max;&#125;\n\n\n分治算法\n\n分治算法就是将一个复杂的问题分成几个相似或者相同的小问题，再将小问题合并。\n本题思路：\n分成多段，分别找出其中连续子数组中的最大和\n\n如果只有1个元素，那么最大和就是那个元素\n\n如果有多个元素，那么递归拆分\n\n合并求最大和时，加入分治了两个数组a、b, 针对两个数组合并\n\n分别拿两个数组每个元素的和得出一个iSum(跨数组)\n分别拿两个数组的头作为起点算个最大和lSum = Max{a.lSum, b.lSum + a.iSum}\n分别拿两个数组的尾巴作为终点算个最大和rSum = Max{b.rSum, a.rSum + b.iSum} 比较的都是不跨数组和跨数组的情况\n两个数组的最大和为 mSum = Max{a.mSum, b.mSum, a.rSum + b.lSum}\n\n\n\nfunction Status(l, r, m, i)&#123;    this.lSum = l    this.rSum = r    this.mSum = m    this.iSum = i&#125;function mergeArr(aStatus, bStatus)&#123;    const l = Math.max(aStatus.lSum, bStatus.lSum + aStatus.iSum)    const r = Math.max(aStatus.rSum + bStatus.iSum, bStatus.rSum)    const m = Math.max(aStatus.mSum, bStatus.mSum, aStatus.rSum + bStatus.lSum)    const i = aStatus.iSum + bStatus.iSum    return new Status(l, r, m, i)&#125;function getInfo(arr, start, end)&#123;    if(start === end)&#123;        return new Status(arr[start], arr[start], arr[start], arr[start])    &#125;    const middle = (start + end) &gt;&gt; 1;    const lStatus = getInfo(arr, start, middle)    const rStatus = getInfo(arr, middle + 1, end)    return mergeArr(lStatus, rStatus)&#125;var maxSubArray = function(nums) &#123;    return getInfo(nums, 0, nums.length - 1).mSum&#125;\n\n剑指 Offer 47. 礼物的最大价值示例在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？\n\n\nTIP 输入\n&gt;[ [1,3,1], [1,5,1], [4,2,1]&gt;]\n输出: 12解释：路径 1→3→5→2→1 可以拿到最多价值的礼物\n\n题解动态规划题，设置dp数组，这个数组存着走到那一步能获取到的最大价值\nvar maxValue = function(grid) &#123;    var line = grid.length;    var column = grid[0].length;    const dp = new Array(line).fill(0).map(() =&gt; new Array(column).fill(0))    dp[0][0] = grid[0][0] // 这个初始值必须设置    for(var i = 0;i &lt; line;i++)&#123; // 初始化每一列        dp[i][0] = dp[i - 1][0] + grid[i][0]    &#125;    for(var j = 0; j &lt; column;j++)&#123;        dp[0][j] = dp[0][j - 1] + grid[0][j - 1]    &#125;    for(var i = 1; i &lt; line;i++)&#123;        for(var j = 1;j &lt; column;j++)&#123;            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]        &#125;    &#125;    return dp[line - 1][column - 1]&#125;\n\nDay10——动态规划二（中等）剑指 Offer 46. 把数字翻译成字符串示例\n\nTIP 输入\n&gt;12258\n输出:5解释: 12258有5种不同的翻译，分别是”bccfi”, “bwfi”, “bczi”, “mcfi”和”mzi”\n\n题解动态规划，滚动数组，条件判断(类似青蛙跳台阶)\n\nF(n) = F(n - 1) (如果最后两个数无法构成一个字母)\nF(n) = F(n - 1) + F(n - 2) (如果最后两个数可以构成一个字母)\n\nvar translateNum = function(num) &#123;    let stringNum = String(num)    let p = 0, q = 1, ways = 1;    for(var i = 0; i &lt; stringNum.length;i++)&#123;        p = q;        q = ways;        ways = 0;        ways += q;        let lastSecondNum = stringNum[i - 1] + stringNum[i]        if(Number(lastSecondNum) &gt;= 10 || (Number(lastSecondNum) &lt;= 25)&#123;            ways += p        &#125;    &#125;    return ways;&#125;\n\n剑指 Offer 48. 最长不含重复字符的子字符串示例\n\nTIP 输入\n&gt;&quot;abcabcbb&quot;\n输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。\n\n题解\n滑动窗口(双指针) + 哈希表\n\nvar lengthOfLongestSubstring = function(s) &#123;    if(!s.length) return 0;    let left = -1, res = 0, hashMap = new Map();    for(var i = 0; i &lt; s.length; i++)&#123;        if(hashMap.has(s[i]))&#123; // 如果存在            const index = hashMap.get(s[i])            left = Math.max(index, left)        &#125;        hashMap.set(s[i], i)        res = Math.max(res, i - left)    &#125;    return res;&#125;\n\nDay11——双指针（简单）剑指 Offer 18. 删除链表的节点示例\n\nTIP 输入\n&gt;head &#x3D; [4,5,1,9], val &#x3D; 5\n输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.\n\n题解建一个空的头结点，定义两个指针，一个先走一步，一个后走\n\n注意点：head也要指向空节点，因为头结点也有可能被删除\n\nvar deleteNode = function(head, val) &#123;    const empty = new ListNode()    empty.next = head;    let prev = empty;    let node = empty;    head = empty    while(node)&#123;        if(node.val === val)&#123;            prev.next = node.next        &#125;        prev = node;        node = node.next    &#125;    return head.next&#125;\n\n剑指 Offer 22. 链表中倒数第k个节点示例\n\nTIP 输入\n&gt;给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 k &#x3D; 2.\n输出: 返回链表 4-&gt;5.\n\n题解解题思路：双指针，前一个指针先走k步，第二根指针开始走，第一个指针走完的时候第二个指针走到第k个元素\nvar getKthFromEnd = function(head, k) &#123;    var front = head;    var back = head;    var i = 1;    while(front)&#123;        if(i &gt; k)&#123;            back = back.next        &#125;        front = front.next        i++    &#125;    return back;&#125;\n\nDay12——双指针二（简单）剑指 Offer 25. 合并两个排序的链表示例\n\nTIP 输入\n&gt;1-&gt;2-&gt;4, 1-&gt;3-&gt;4\n输出:1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4\n\n题解一根新链表加两个指针\n/** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//** * @param &#123;ListNode&#125; l1 * @param &#123;ListNode&#125; l2 * @return &#123;ListNode&#125; */var mergeTwoLists = function(l1, l2) &#123;    let node1 = l1;    let node2 = l2;    const newHead = new ListNode();    let newNode = newHead;    while(node1 &amp;&amp; node2)&#123;        if(node2.val &lt;= node1.val)&#123;            newNode.next = node2            node2 = node2.next;        &#125;        else&#123;            newNode.next = node1;            node1 = node1.next        &#125;        newNode = newNode.next    &#125;    newNode.next = node1 ? node1 : node2    return newHead.next&#125;;\n\n剑指 Offer 52. 两个链表的第一个公共节点示例\n\nTIP 输入输出:Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n\n题解双指针，一根走完了指向另一根的头部, 相交说明有公共节点，都为null说明没有。类似于找环状链表\nvar getIntersectionNode = function(headA, headB) &#123;    if (headA === null || headB === null) &#123;        return null;    &#125;    var nodeA = headA;    var nodeB = headB;    while(nodeA !== nodeB)&#123;        nodeA = nodeA ? nodeA.next : headB;        nodeB = nodeB ? nodeB.next : headA;    &#125;    return nodeA&#125;;\n\nDay13——双指针三（简单）剑指 Offer 21. 调整数组顺序使奇数位于偶数前面示例\n\nTIP 输入\n&gt;nums &#x3D; [1,2,3,4]\n输出:[1,3,2,4]\n\n题解双指针，一根指向头，一根指向尾部，同时往中间移动\n头部指针移动到第一个偶数位置停止\n尾部指针移动到第一个奇数位置停止\nvar exchange = function(nums) &#123;    if(!nums.length) return [];    let i = 0, j = nums.length - 1;    while(i &lt; j)&#123;        while(i &lt; j &amp;&amp; (nums[i] &amp; 1) === 1) i++;        while(i &lt; j &amp;&amp; (nums[i] &amp; 1) === 0) j--;        let temp = nums[i];        nums[i] = nums[j]        nums[j] = temp    &#125;    return nums;&#125;\n\n剑指 Offer 57. 和为s的两个数字示例\n\nTIP 输入\n&gt;nums &#x3D; [2,7,11,15], target &#x3D; 9\n输出:[2,7] 或者 [7,2]\n\n题解头尾指针和小，头指针往后，和大，尾指针往前\nvar twoSum = function(nums, target) &#123;    let i = 0; j = nums.length - 1    while(i &lt; j)&#123;        if(nums[i] + nums[j] === target) &#123;            return [nums[i], nums[j]]        &#125;        if(nums[i] + nums[j] &gt; target)&#123;            j--        &#125;        if(nums[i] + nums[j] &lt; target)&#123;            i++        &#125;    &#125;    return []&#125;;\n\n剑指 Offer 58 - I. 翻转单词顺序示例\n\nTIP 输入\n&gt;&quot;  hello world!  &quot;\n输出:”world! hello”解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。\n\n题解var reverseWords = function(s) &#123;    const wordArray = s.trim().split(' ').filter(item =&gt; item !== '')    let i = 0, j = wordArray.length;    while(i &lt; j)&#123;        let temp = wordArray[i];        wordArray[i] = wordArray[j];        wordArray[j] = temp        i++;        j--;    &#125;    return wordArray.join(' ').trim()&#125;;\n\nDay14——搜索与回溯算法（中等）剑指 Offer 12. 矩阵中的路径给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。\n单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。\n例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。\n\n示例\n\nTIP 输入\n&gt;board &#x3D; [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word &#x3D; &quot;ABCCED&quot;\n输出:true\n\n题解回溯思想: 类似于在一个节点的枚举过程，不满足条件就回到那个节点\n本题思路：\n\n从盘中任意一个节点开始走，因此是一个二重循环，需要考虑每一个节点，有一个节点满足则返回true\n对每一个节点进行枚举，不满足条件则回溯，满足条件的标记需要标记已经访问过了，避免再次访问\n\nvar exist = function(board, word) &#123;    const line = board.length;    const column = board[0].length;    let flag = false;    const visited = new Array(line).fill(false).map(() =&gt; new Array(column).fill(false))      const checkWords = (i, j, _word, k) =&gt; &#123;        // 走的方向        const directions = [[1, 0], [0, 1], [-1, 0], [0, -1]]        if(board[i][j] !== word.charAt(k))&#123;            return false        &#125;        if(k === _word.length - 1)&#123;            return true        &#125;        visited[i][j] = true;        let result = false;        for(var [dx, dy] of directions)&#123;            const newX = i + dx;            const newY = j + dy;            if(newX &gt;= 0 &amp;&amp; newY &gt;= 0 &amp;&amp; newX &lt;= line &amp;&amp; newY &lt;= column)&#123;                if(!visited[newX][newY])&#123;                    const res = checkWords(newX, newY, _word, k + 1)                    if(res)&#123;                        result = true;                        break;                    &#125;                &#125;            &#125;        &#125;        return result;    &#125;    for(var i = 0; i &lt; line;i++)&#123;        for(var j = 0;j &lt; column;j++)&#123;            flag = checkWords(i, j, word, 0)            if(flag)&#123;                return true            &#125;        &#125;    &#125;&#125;\n\n剑指 Offer 13. 机器人的运动范围示例地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？\n\n\nTIP 输入\n&gt;m &#x3D; 2, n &#x3D; 3, k &#x3D; 1\n输出:3\n\n题解是一个深度优先遍历或者广度优先遍历的题\n深度优先遍历：相当于暴力的算法，一个方向走到底，然后回溯到节点再走\n广度优先遍历：\nvar movingCount = function(m, n, k) &#123;    const visited = new Array(m).fill(0).map(() =&gt; new Array(n).fill(false)) // 标记是否访问    const calc = (val) =&gt; &#123;        let sum = 0;        while(x !== 0)&#123;            sum += x % 10;            x = Math.floor(x / 10);        &#125;        return sum    &#125;    const walk = (visit, m, n, i, j, k) =&gt;&#123;        const sum = calc(i) + calc(j);        if(sum &gt; k || visit[i][j] || i &gt; m || j &gt; n) return 0;        visit[i][j] = true;        return 1 + walk(visit, m, n, i + 1, j, k) + walk(visit, m, n, i, j + 1, k)    &#125;        return walk(visited, m, n, 0, 0, k)&#125;","categories":["算法","面试"],"tags":["面试","算法"]},{"title":"重学Hooks——useEffect","url":"/2020/07/26/useEffect/","content":"\nDan在OverReact上发表的文章深入浅出，本文只针对个人之前不理解的点进行思考，采用了他的案例，参考了他的文章——useEffect的完整指南.\n\n在我看来，Effect hook是React Hooks中最强大最核心的一个hook，是驱动整个程序的纽带我也将采用Dan的案例进行思考\n\n\n根据文章问题，进行思考后，抛出了以下几个问题，将在下文对这几个问题做详细的思考\nEffect是如何进行渲染的?\n如何用Effect模拟React的生命周期？useEffect(fn,[])和componentDidMount一样吗？\n如何正确的使用Effect请求数据？\nEffect的依赖到底用什么，可以用函数嘛，什么时候用函数作为依赖？\nEffect Hook怎么会导致死循环？\nEffect Hook怎么会拿到旧state和props，如果我真的想用旧的state和props，我应该怎么去获取？\n\n\n\n\n\nEffect到底是如何渲染的?渲染中state的渲染\n以下是最简单的点击次数加一的事件， 分析一下点击后数字的改变\n\nfunction Counter() &#123;  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );&#125;\n以下展示了count改变的来源，并非是通过事件监听或是事件绑定或是代理等对count本身做出的改变，而是重新创建了一个count， 新创建的count值是最后一次改变的state中的count.\n\n\n\n点击次数\n值\ncount来源\n\n\n\n0\n0\nuseState默认值\n\n\n1\n1\n上一个useState的返回值\n\n\n2\n2\n上一个useState的返回值\n\n\n代码体现则是如下\n// During first renderfunction Counter() &#123;  const count = 0; // Returned by useState()  // ...  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;  // ...&#125;// After a click, our function is called againfunction Counter() &#123;  const count = 1; // Returned by useState()  // ...  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;  // ...&#125;// After another click, our function is called againfunction Counter() &#123;  const count = 2; // Returned by useState()  // ...  &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;  // ...&#125;\n\n因此发现，其实count只是一个常量，React在使用setCount后，带着一个新count再次调用组件!\n至于更深入的研究，还未研究过，准备参考Dan的另一篇文章将 React 作为 UI 运行时\n\n\n\n\n\n渲染中事件处理函数的渲染function Counter() &#123;  const [count, setCount] = useState(0);  function handleAlertClick() &#123;    setTimeout(() =&gt; &#123;      alert('You clicked on: ' + count);    &#125;, 3000);  &#125;  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;/button&gt;      &lt;button onClick=&#123;handleAlertClick&#125;&gt;        Show alert      &lt;/button&gt;    &lt;/div&gt;  );&#125;\n\n我们按照以下步骤做\n我先点击到按钮，使count到达1\n点击show alert，再3秒内迅速点击按钮使count到3\n观察alert的值， 值为1 or 3 ?? \n\n\n\n点我操作，看看到底是个啥\n\n根据上文，以下展示了这个调用的情况\n\n\n\n\n是否点击alert\n此时点击次数\n值\ncount来源\nhandleAlertClick\n\n\n\n否\n0\n0\nuseState默认值\nhandleAlertClick中的count取0\n\n\n否\n1\n1\n上一个useState的返回值\nhandleAlertClick中的count取1\n\n\n是\n1\n1\n上一个useState的返回值\nhandleAlertClick中的count取1\n\n\n否\n2\n2\n上一个useState的返回值\nhandleAlertClick中的count取2\n\n\n否\n3\n3\n上一个useState的返回值\nhandleAlertClick中的count取3\n\n\nalert弹出\n…\n…\n…\n弹出表格对应的第三行的handleAlertClick\n\n\n\n我们发现，每次调用的count和handleAlertClick，都是重新创建的count和handleAlertClick，每次重新渲染组件，上一次的栈内存都将被释放。由于闭包，第一次的count并未被释放，而handleAlertClick被存放在了任务队列，记录的是没有被释放的count，哪怕点到了3，与之前的也没有任何关系，每次渲染都是独立的，因此值是1。\n\n每次渲染的state和props在渲染中是不会被改变的，因此每次渲染都是独立的，每次渲染的state和props都是不同的state和props。这种独立关系，再修改引用类型时，希望我们setObject(newObject)，这样可以保证上一个state不被污染\n问题1：Effect清理与浏览器渲染屏幕的执行顺序是什么样的呢？// First render, props are &#123;id: 10&#125;function Example() &#123;  // ...  useEffect(    // Effect from first render    () =&gt; &#123;      ChatAPI.subscribeToFriendStatus(10, handleStatusChange);      // Cleanup for effect from first render      return () =&gt; &#123;        ChatAPI.unsubscribeFromFriendStatus(10, handleStatusChange);      &#125;;    &#125;  );  // ...&#125;// Next render, props are &#123;id: 20&#125;function Example() &#123;  // ...  useEffect(    // Effect from second render    () =&gt; &#123;      ChatAPI.subscribeToFriendStatus(20, handleStatusChange);      // Cleanup for effect from second render      return () =&gt; &#123;        ChatAPI.unsubscribeFromFriendStatus(20, handleStatusChange);      &#125;;    &#125;  );  // ...&#125;\n\n按照常理的逻辑，是这个顺序吗？？？？？？？\n\n\n\n次数\n操作\n\n\n\n1\n渲染props.id为10的UI\n\n\n2\n执行Effect，订阅数据\n\n\n3\n清除id为10的Effect\n\n\n4\n渲染props.id为20的UI\n\n\n5\n执行Effect，订阅数据\n\n\nyes？？？？\n\n\n\nNo\n\n\n\n结果应该是如下的\n\n\n\n次数\n操作\n\n\n\n1\n渲染props.id为10的UI\n\n\n2\n执行Effect，订阅数据\n\n\n3\n渲染props.id为20的UI\n\n\n4\n清除id为10的Effect\n\n\n5\n执行Effect，订阅数据\n\n\n因为Effect的执行一定是放在浏览器渲染屏幕之后的！因为每次渲染都是独立的，上一个Effect只能记住id为10的状态，因此，effect的清除并不会读取最新的props。它只能读取到定义它的那次渲染中的props值。\n问题2：每次渲染的Effect都是不同的Effect嘛？那么Effect中的state和外部state是什么关系？每次渲染的Effect都是不同的EffectEffect中的state和props，都是特定的那次渲染的state和props\nReact执行Effect的时机是什么？function Counter() &#123;  const [count, setCount] = useState(0);    // console.log('effect外部被执行了')    useEffect(() =&gt; &#123;        // console.log('effect内部被执行了')        document.title = count    &#125;)  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );&#125;\n\n执行顺序如下\n执行const [count, setCount] = useState(0);\nReact记住Effect\n渲染dom\n调用document.title = count\n\n\n因此我们要记住，Effect是在每次更改作用于DOM并让浏览器绘制屏幕后去调用它\n\nEffect中的异步针对同步的情况，已经了解的差不多了，那么如果Effect中有延迟呢？\nfunction Counter() &#123;  const [count, setCount] = useState(0);  useEffect(() =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(`You clicked $&#123;count&#125; times`);    &#125;, 3000);  &#125;);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );&#125;\n假如我点击三次，将会打印什么，结论如下，原因很简单，因为每一个Effect中保存的是当前的count\nYou clicked 0 timesYou clicked 1 timesYou clicked 2 timesYou clicked 3 times\n\n但是！上述工作机制与类并不相同，hooks写法中，每一个count是独立的，类写法中，将会输出一次you clicked 0 times和3次you clicked 3 times，原因是因为类写法中的count是同一个count\n这原来就是困扰我好久好久的Effect中的闭包啊\n问题来了，如果我就想打印3次you clicked 3 times怎么办ref登场\n不同于class中的ref，hooks中的ref不仅可以保存dom元素，他可以作为任何值的容器function Example() &#123;  const [count, setCount] = useState(0);  const latestCount = useRef(count);  useEffect(() =&gt; &#123;    // Set the mutable latest value    latestCount.current = count;    setTimeout(() =&gt; &#123;      // Read the mutable latest value      console.log(`You clicked $&#123;latestCount.current&#125; times`);    &#125;, 3000);  &#125;);\nok，这样就搞定啦，官网说了， useRef返回的对象，在整个生命周期内保持不变，因此不用担心每次创建的都是新的ref，这样我Effect函数中改变的ref内的容器值，都是同一个。\n文章上半部分已经可以解决我们开篇提到的1、2、5、6三个问题Effect到底是怎么更新的？\n\n\n告诉React你要做什么样的比对\n我想关于这个依赖项，React文档做了更详尽的阐述。这里只拎几个点出来\n\n类似于setState的函数式更新function Counter() &#123;  const [count, setCount] = useState(0);  useEffect(() =&gt; &#123;    const id = setInterval(() =&gt; &#123;      setCount(count + 1);    &#125;, 1000);    return () =&gt; clearInterval(id);  &#125;, []);  return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;\n\n由于每次渲染都是独立的，我们知道，这里count永远都是1\n解决方案如下：\n1、设置count作为依赖项\n虽然解决了问题，但是非常不好，代码如下，原因是因为每次修改count，都将重新生成一个定时器，useEffect都会被重新执行，这显然不是我们想要的结果\n\n\n2、函数式更新\n比较理想的解决方案\n\n\n\n\n\n// 设置count为依赖项function Counter() &#123;  const [count, setCount] = useState(0);  useEffect(() =&gt; &#123;    const id = setInterval(() =&gt; &#123;      setCount(count + 1);    &#125;, 1000);    return () =&gt; clearInterval(id);  &#125;, [count]);  return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;\n\n// 函数式更新function Counter() &#123;  const [count, setCount] = useState(0);  useEffect(() =&gt; &#123;    const id = setInterval(() =&gt; &#123;      setCount(c =&gt; c + 1);    &#125;, 1000);    return () =&gt; clearInterval(id);  &#125;, []);  return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;\n\n这种函数式更新，无需知道count的值，React已经知道，并将最新的count传递进去。成功将依赖项count移除\n\n但是\n我不仅想要知道最新的count，我还想要知道最新的props或是其他的state。。（函数式更新凉凉）\nfunction Counter() &#123;  const [count, setCount] = useState(0);  const [step, setStep] = useState(1);  useEffect(() =&gt; &#123;    const id = setInterval(() =&gt; &#123;      setCount(c =&gt; c + step);    &#125;, 1000);    return () =&gt; clearInterval(id);  &#125;, [step]);  return (    &lt;&gt;      &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;      &lt;input value=&#123;step&#125; onChange=&#123;e =&gt; setStep(Number(e.target.value))&#125; /&gt;    &lt;/&gt;  );&#125;\n炸了，不是我们想要的\nuseReducer\n首先我们要知道，什么时候用这个useReducer？这里引用了React文档的内容。\n在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数。\n\n\n\n这里默认已经会Redux了。\n\n关键点：\n\n逻辑复杂\n\n\n\n状态依赖\n\n\n\n嵌套深的组件性能优化其中第二点就是我们说的那一点，因此上面的案例可以改写为:\n\n\n\n\n\nfunction Counter() &#123;  const [state, dispatch] = useReducer(reducer, initialState);  const &#123; count, step &#125; = state;  useEffect(() =&gt; &#123;    const id = setInterval(() =&gt; &#123;      dispatch(&#123; type: 'tick' &#125;);    &#125;, 1000);    return () =&gt; clearInterval(id);  &#125;, [dispatch]);  return (    &lt;&gt;      &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;      &lt;input value=&#123;step&#125; onChange=&#123;e =&gt; &#123;        dispatch(&#123;          type: 'step',          step: Number(e.target.value)        &#125;);      &#125;&#125; /&gt;    &lt;/&gt;  );&#125;const initialState = &#123;  count: 0,  step: 1,&#125;;function reducer(state, action) &#123;  const &#123; count, step &#125; = state;  if (action.type === 'tick') &#123;    return &#123; count: count + step, step &#125;;  &#125; else if (action.type === 'step') &#123;    return &#123; count, step: action.step &#125;;  &#125; else &#123;    throw new Error();  &#125;&#125;\n\n关键点： 用dispatch替代依赖(dispatch会保证生命周期内保持不变)\n这种模式的好处：通过reducer让我们不必再关心state和props的状态，成功达到了解耦的目的。\n\n但是问题来了，如果我每次都想获取最新的props，还有戏嘛？\n有的，把reducer扔组件里\n每次dispatch，都会调用reducer，这时候reducer获取的就是最新的props了。\nfunction Counter(&#123; step &#125;) &#123;  const [count, dispatch] = useReducer(reducer, 0);  function reducer(state, action) &#123;    if (action.type === 'tick') &#123;      return state + step;    &#125; else &#123;      throw new Error();    &#125;  &#125;  useEffect(() =&gt; &#123;    const id = setInterval(() =&gt; &#123;      dispatch(&#123; type: 'tick' &#125;);    &#125;, 1000);    return () =&gt; clearInterval(id);  &#125;, [dispatch]);  return &lt;h1&gt;&#123;count&#125;&lt;/h1&gt;;&#125;\n难怪Dan说是Hooks的作弊模式\n接下来，我们着重解决第三和第四个问题\nEffect中的数据请求\n直接上案例\n这个模式曾经也是我在不是很懂Effect的情况下经常使用的模式，我曾经对eslint-plugin-react-hooks这个插件提供的警告存有很大的疑问，现在终于明白了。\n乍一看？没问题！\nfunction SearchResults() &#123;  // Imagine this function is long  function getFetchUrl() &#123;    return 'https://hn.algolia.com/api/v1/search?query=react';  &#125;  // Imagine this function is also long  async function fetchData() &#123;    const result = await axios(getFetchUrl());    setData(result.data);  &#125;  useEffect(() =&gt; &#123;    fetchData();  &#125;, []);&#125;\n\n但是上述模式存在一个弊端，如果我们忘记写入依赖，那么我们的effects就不会同步props和state带来的变更。这当然不是我们想要的。\n\n我们把他放进去，前提是某些函数仅在effect中调用。\nfunction SearchResults() &#123;  // ...  useEffect(() =&gt; &#123;    // We moved these functions inside!    function getFetchUrl() &#123;      return 'https://hn.algolia.com/api/v1/search?query=react';    &#125;    async function fetchData() &#123;      const result = await axios(getFetchUrl());      setData(result.data);    &#125;    fetchData();  &#125;, []); // ✅ Deps are OK  // ...&#125;\n还是没问题吗？是的，没问题了。\n稍微修改一下，使请求url中需要我们的状态，对，就是这么请求。\nfunction SearchResults() &#123;  const [query, setQuery] = useState('react');  useEffect(() =&gt; &#123;    // Imagine this function is also long    function getFetchUrl() &#123;      return 'https://hn.algolia.com/api/v1/search?query=' + query;    &#125;    // Imagine this function is also long    async function fetchData() &#123;      const result = await axios(getFetchUrl());      setData(result.data);    &#125;    fetchData();  &#125;, [query]);&#125;\n但我曾经有一次，在封装自定义Hook的时候，我将request提供给自定义hook，但是我却没法将我的state或者是props放进自定义hook，因为他们属于不同的js文件，这可怎么办？说白了，就是逻辑复用咋搞。\nuseCallback这个Hook很简单，缓存一个函数，只在函数本身需要改变的时候调用副作用\n怎么知道这个函数是否需要改变，通过第二个参数\nfunction SearchResults() &#123;  const [query, setQuery] = useState('react');  const getFetchUrl = useCallback(() =&gt; &#123;    return 'https://hn.algolia.com/api/v1/search?query=' + query;  &#125;, [query]);  // ✅ Callback deps are OK  useEffect(() =&gt; &#123;    const url = getFetchUrl('react');    // ... Fetch data and do something ...  &#125;, [getFetchUrl]); // ✅ Effect deps are OK&#125;\n问题解决！\nDan对class模式和hooks模式的这种网络请求没法放入依赖的情况分别作了比较，当request作为请求向下传递的情况。这里不细说了，class模式本身不是数据流的一部分，因此他必须将不必要的query传下去才能再componentDidUpdate中发生响应，而Hooks就完美的解决了这个问题\n在我看来，useCallback就是一个工具人，我是老板，你没法直接跟我说话，就跟我秘书说。我秘书会传达给我的。\nOK！1、2、3、4、5、6问题全都解决了！\n总结&amp;致谢前前后后通读了Dan的文章好多遍，并看了好几遍Effect的文档。初识Effect，似乎很简单，随着项目的锻炼，发现越来越难以管理自己的状态。花心思重新学了一下Effect。让我更清晰的明白了设计Hooks的初衷和目的，找到正确使用的姿势。\n从阅读到完成，花了大概有半个月，主要参考资料来自Dan的Overreacted上的一篇文章useEffect完整指南。\n","categories":["React"],"tags":["前端","React","Hooks"]},{"title":"手把手搭建一个React应用程序","url":"/2021/01/10/%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE/","content":"本应用程序为webpack5.0 + React17 + antd4.x\n搭建环境初始化项目初始化包我们使用npm先创建一个package.json, 安装webpack&nbsp;&nbsp;&nbsp;  webpack-cli &nbsp;&nbsp;&nbsp;react &nbsp;&nbsp;&nbsp; react-dom &nbsp;&nbsp;&nbsp; react-router-dom\nnpm init -yyarn add webpack webpack-cli --devyarn add react react-dom react-router-dom\n\n根目录创建webpack.config.js(暂时只考虑开发环境)\n根目录下创建app文件夹作为我们的应用程序主入口,入口文件为app.js\n项目结构如下\n├─ app   |-app.js├─ node_modules    |- ......├─ webpack.config.js└─ package.json\n\n\n\n配置基本webpack这里我们配置一些基本的webpack打包必须的配置项\nconst path = require(\"path\")module.exports = &#123;    entry: &#123;       index: &#123;        import: '/app/app.js',      &#125;,    &#125;,    mode: \"development\",    output: &#123;        filename: '[name].[contenthash].bundle.js',        chunkFilename: '[name].[id].js',        publicPath: '/',        path: path.resolve(__dirname, 'dist'),    &#125;,    devtool: 'inline-source-map',&#125;\n管理资源我们需要解析模块, 生成bundle, 这里我们使用babel-loader来转换js, less-loader &nbsp;&nbsp;&nbsp; css-loader &nbsp;&nbsp;&nbsp; style-loader来加载样式\nyarn add less less-loader --devyarn add babel-loader --devyarn add css-loader style-loader --dev\n\n\nconst path = require(\"path\")module.exports = &#123;    entry: &#123;       index: &#123;        import: '/app/app.js',      &#125;,    &#125;,    mode: \"development\",    output: &#123;        filename: '[name].[contenthash].bundle.js',        chunkFilename: '[name].[id].js',        publicPath: '/',        path: path.resolve(__dirname, 'dist'),    &#125;,    devtool: 'inline-source-map',    module: &#123;        rules: [          &#123;            test: /\\.js$/,            exclude: /(node_modules)/,            include: path.resolve(__dirname, 'app'),            use: &#123;              loader: 'babel-loader',              options: &#123;                presets: ['@babel/preset-env']              &#125;            &#125;          &#125;,          &#123;            test: /\\.less$/i,            use: ['style-loader', 'css-loader', 'less-loader'],          &#125;,          &#123;            test: /\\.css$/i,            use: ['style-loader', 'css-loader'],          &#125;,        ],    &#125;&#125;\n\n由于用到了babel转换js,我们需要装一些babel的核心模块\nyarn add @babel/core @babel/cli @babel/preset-env --dev\n\n添加调试基础插件接下来装一些便于我们调试的基础插件html-webpack-plugin &nbsp;&nbsp;&nbsp;clean-webpack-plugin &nbsp;&nbsp;&nbsp;webpack-manifest-plugin\nyarn add html-webpack-plugin clean-webpack-plugin webpack-manifest-plugin --dev\n\n创建模板index.html, 并添加插件\n&lt;html&gt;  &lt;head&gt;    &lt;meta charset=\"utf-8\" /&gt;    &lt;title&gt;起步&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div id=\"app\"&gt;&lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n// webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin');const &#123; CleanWebpackPlugin &#125; = require('clean-webpack-plugin');const &#123; WebpackManifestPlugin &#125; = require('webpack-manifest-plugin');module.exports = &#123;    entry: &#123;       index: &#123;        import: '/app/app.js',      &#125;,    &#125;,    mode: \"development\",    output: &#123;        filename: '[name].[contenthash].bundle.js',        chunkFilename: '[name].[id].js',        publicPath: '/',        path: path.resolve(__dirname, 'dist'),    &#125;,    devtool: 'eval-source-map',    devServer: &#123;      contentBase: '/dist',    &#125;,    module: &#123;        rules: [          &#123;            test: /\\.js$/,            exclude: /(node_modules)/,            include: path.resolve(__dirname, 'app'),            use: &#123;              loader: 'babel-loader',              options: &#123;                presets: ['@babel/preset-env']              &#125;            &#125;          &#125;,          &#123;            test: /\\.less$/i,            use: ['style-loader', 'css-loader', 'less-loader'],          &#125;,          &#123;            test: /\\.css$/i,            use: ['style-loader', 'css-loader'],          &#125;,        ],    &#125;,    plugins: [      new CleanWebpackPlugin(),      new HtmlWebpackPlugin(&#123;        inject: true,        template: '/app/index.html',      &#125;),      new WebpackManifestPlugin()    ],&#125;\n\n创建服务新建本地服务, 添加模块热更新, 这里我们使用Express启动服务\n我们在根目录创建一个server的文件夹, 创建一个index.js文件, 编写我们的启动脚本\n这里我们需要安装webpack-dev-server &nbsp;&nbsp;&nbsp; webpack-dev-middleware\nyarn add expressyarn add webpack-dev-server --devyarn add webpack-dev-middleware --dev\n\n// /server/index.jsconst express = require('express');const webpack = require('webpack');const webpackDevMiddleware = require('webpack-dev-middleware');const app = express();const config = require('./webpack.config.js');const compiler = webpack(config);// 告知 express 使用 webpack-dev-middleware，// 以及将 webpack.config.js 配置文件作为基础配置。app.use(  webpackDevMiddleware(compiler, &#123;    publicPath: config.output.publicPath,  &#125;));// 将文件 serve 到 port 3000。app.listen(3000, function () &#123;  console.log('Example app listening on port 3000!\\n');&#125;);\n\nwebpack.config.js文件添加contentBase,表明从哪里去寻找文件\ndevServer: &#123;    contentBase: './dist', // dist为我们的输出目录&#125;,\n\n编写启动脚本我们在package.json中编写一些脚本,便于我们启动服务和打包\n\"scripts\": &#123;    \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\",    \"build\": \"webpack --config webpack.config.js\",    \"start\": \"node server/index.js\"&#125;,\n\n这时候基本的需要已经搭建完成, 我们在app.js中随便写点东西\nconsole.log(123)\n\n解析jsx到此为止我们已经可以正确打包js文件, 正确启动脚本, 安装了应用程序一些必要的依赖, 但是我们还无法解析jsx语法\n如果我们在app.js文件中写如下代码, 启动或编译\n// app.jsimport React from 'react'import ReactDOM from 'react-dom'ReactDOM.render(&lt;div&gt;111&lt;/div&gt;, document.getElementById(\"app\"))\n我们会看到如下报错\n因此我们需要安装babel转换jsx相关的插件\nyarn add @babel/preset-react --dev\n\n按照babel官网的教程,在根目录下创建babel.config.json\n此时项目结构如下\n├─ app   |-app.js├─ node_modules    |- ......├─ server    ├─ index.js├─ webpack.config.js├─ babel.config.json└─ package.json└─ yarn.lock\n\n在这里我们配一些基础的 js 转换的预设, 这里包括一个解析 jsx 的babel预设,一个js转换的预设, 这里 module 设置为 false 是根据当前的调用者判断其已经支持ES6模块语法，则默认的auto将自动选择false，否则将选择 commonjs, 这里手动设置为 false 将不支持将 ES6 模块语法转换为其他模块类型\n// babel.config.json&#123;    \"presets\": [      [        \"@babel/env\",        &#123;          \"useBuiltIns\": \"usage\",          \"module\": false        &#125;      ],      [\"@babel/preset-react\",         &#123;          \"development\": true        &#125;      ]    ],&#125;\n这里注意,babel 中preset顺序是从后往前执行,plugin的顺序是从后往前执行\n再次打包后成功\n我们启动下试试看\n同样, 使用class的写法也能正确解析, 这里有个注意点, 针对类, 我们需要使用@babel/plugin-proposal-class-properties,否则如下代码无法编译\nclass A &#123;    say = () =&gt; &#123;        console.log('我说话了')    &#125;&#125;let a = new A()a.say()\n\nyarn add @babel/plugin-proposal-class-properties --dev\n\n// babel.config.json&#123;    \"presets\": [      [        \"@babel/env\",        &#123;          \"useBuiltIns\": \"usage\",          \"module\": false        &#125;      ],      [\"@babel/preset-react\",         &#123;          \"development\": true        &#125;      ]    ],    \"plugins\": [        [\"@babel/plugin-proposal-class-properties\", &#123; \"loose\": true &#125;]    ]&#125;\n\n安装antdyarn add antd\n我们修改app.js,导入antd的Button看看效果如何\n// app.jsimport React from 'react'import ReactDOM from 'react-dom'import &#123; Button &#125; from 'antd'class MyDemo extends React.Component&#123;    constructor(props)&#123;        super(props)        this.state = &#123;            buttonText: \"我是按钮\"        &#125;    &#125;    render()&#123;        return &lt;Button&gt;&#123;this.state.buttonText&#125;&lt;/Button&gt;    &#125;&#125;ReactDOM.render(&lt;MyDemo /&gt;, document.getElementById(\"app\"))\n结果是确实引入了antd的组件,但是并未引入antd的样式\n我们选择使用babel动态导入的方法引入样式\nyarn add babel-plugin-import --dev\n\n然后修改babel.config.json配置\n// babel.config.json&#123;    \"presets\": [      [        \"@babel/env\",        &#123;          \"useBuiltIns\": \"usage\",          \"modules\": false         &#125;      ],      [\"@babel/preset-react\",         &#123;          \"development\": true        &#125;      ]    ],    \"plugins\": [        [\"@babel/plugin-proposal-class-properties\", &#123; \"loose\": true &#125;],        [\"import\", &#123; \"libraryName\": \"antd\", \"libraryDirectory\": \"es\", \"style\": \"css\" &#125;]    ]&#125;\n结果如下\n\n浏览器兼容为了确保项目需要, 我们保持ie10及以上的兼容, babel会根据配置文件的target, package.json, 根目录browserslist依次去寻找浏览器版本.这里我们在 package.json 中配置 browerslist\n\"browserslist\": [    \"last 1 version\",    \"&gt; 1%\",    \"IE 10\"]\n\n运行 npx browerslist得到如下图\n\n","categories":["React"],"tags":["前端","React","webpack"]},{"title":"初探CKEditor5","url":"/2022/04/20/%E5%88%9D%E6%8E%A2CKEditor5/","content":"选择的原因这里将wangEditor5与CkEditor5作为比较\n\nCkEditor优势 \n文档详细\n用户量大\n自定义插件扩展非常容易\n\n\nCkEditor劣势 \n纯英文文档，无翻译\n未解决的_issues_尚且较多\n\n\n\nnpm月下载量比较CKEditor月下载量如下图所示：\nwangEditor月下载量如下图所示：\n结论：CKEditor的月下载量吊打了wangEditor，并且最新的wangEditor5月下载量不过1400，个人比较倾向于使用月下载量10000+的\ngithub关键数据比较：CKEditor的GitHub星星数与issues数量如下图所示：\n\nwangEditor的GitHub星星数与issues数量如下图所示：\n\n结论：wangEditor在star上和处理问题的及时程度秒杀了CKEditor, 这一定程度可能也是CKEditor的star如此少的原因，但介于wangEditor是由国人开发，国人开发的特点是star量比较虚，实际使用量和其star量不成正比，参考字节跳动web infra团队开源的Modern.js\n打包体积比较相同功能的情况下CKEditor体积\nwangEditor体积\n结论：\n\n同样的功能CKEditor的打包体积更小，B端要求不高，C端原则基本遵循满足需求的情况下，能使用小的就使用小的\nCKEditor功能栏采取按需加载的方式，即我们如果不需要某些功能，那些功能文件就不会被打包，测试了一下如果只留一个Bold插件的情况下可以减少_42.2kb_的js体积\n\n\n功能比较主要功能大同小异，性能上的表现也几乎一致，CKEditor的亮点在于其插件化的扩展更加友好， 除了自己编写插件，还可以继承已有的插件，重写对应的插件方法，如果需要继承，官网的插件都是提供对应的方法的，重写方法就好。并且插件的编写方式类似于编写webpack的插件，提供了一系列的钩子在特定的条件下执行，后面会详细介绍。\nCkEditor基本环境搭建根据业务需要, 使用create-react-app搭建项目, 使用react-app-rewired启动项目, 使用customize-cra修改webpack配置\n安装yarn add --dev \\    css-loader@5 \\    postcss-loader@4 \\    raw-loader@4 \\    style-loader@2 \\    webpack@5 \\    webpack-cli@4\nwebpack配置CKEditor集成到项目中需要重新定义某些文件的解析规则否则会报Error: Cannot read property &#39;getAttribute&#39; of null (ckeditor)https://stackoverflow.com/questions/66416928/error-cannot-read-property-getattribute-of-null-ckeditor\n需要做如下解析：\n\n内置的svg文件需要使用raw-loader\n如果需要做视觉集成(主题), 内置的css文件优先使用postcss-loader,并且引入@ckeditor/ckeditor5-theme-lark包, 主题将增加约_30kb_的打包体积, 开发者可以酌情考虑。链接如下：https://ckeditor.com/docs/ckeditor5/latest/examples/framework/theme-customization.html\n对于特定的CKEditor中的css样式，可以用如下的正则表达式判断\n\nconst CKERegex = &#123;    svg: /ckeditor5-[^/\\\\]+[/\\\\]theme[/\\\\]icons[/\\\\][^/\\\\]+\\.svg$/,    css: /ckeditor5-[^/\\\\]+[/\\\\]theme[/\\\\].+\\.css/,&#125;;&#123;    loader: 'postcss-loader',    options: &#123;        postcssOptions: styles.getPostCssConfig(&#123;            themeImporter: &#123;                themePath: require.resolve('@ckeditor/ckeditor5-theme-lark')            &#125;,            minify: true        &#125;)    &#125;&#125;\n\n富文本的模式\n经典模式如下\n\nnpm install --save @ckeditor/ckeditor5-build-classic\n\n\n内联模式\n\nnpm install --save @ckeditor/ckeditor5-build-inline\n\n\n气泡模式\n\nnpm install --save @ckeditor/ckeditor5-build-balloon\n\n气泡块模式npm install --save @ckeditor/ckeditor5-build-balloon-block\n\n\n\n文档模式npm install --save @ckeditor/ckeditor5-build-decoupled-document\n\n\n文档链接如下：https://ckeditor.com/docs/ckeditor5/latest/installation/advanced/alternative-setups/predefined-builds.html\n插件添加插件添加逻辑必须遵循官方文档个人比较推荐从以下的网站进去，定义自己的模板https://ckeditor.com/ckeditor-5/online-builder/\n按照指示下载完成后会有以下的文件，还有demo，如下图\n也可以根据已有的插件集，像上图那样的自己去引用官方已有的插件, 对应的所有插件如下：https://ckeditor.com/docs/ckeditor5/latest/features/index.html\n编写CkEditor组件当前组件被antd的Form包裹，作为表单组件\nfunction CKEditor(props) &#123;  const &#123; onChange, readOnly, value, onError &#125; = props;  const handleChange = useCallback((event, editor) =&gt; &#123;    const data = editor.getData();    onChange(data)  &#125;, [onChange])  const handleBlur = useCallback((event, editor) =&gt; &#123;    const data = editor.getData();    onChange(data)  &#125;, [onChange])  return (    &lt;CKEditorContext context=&#123;Context&#125;&gt;      &lt;CKEditor        editor=&#123;ClassicEditor&#125;        config=&#123;&#123;          // 这里可以自定义配置项          removePlugins: ['link', 'insertTable', 'mediaEmbed'],          toolbar: ['bold', 'italic', 'bulletedList', 'numberedList', 'imageUpload'],          // toolbar: ['bold', 'italic']        &#125;&#125;        disabled=&#123;readOnly&#125;        data=&#123;value || '&lt;p /&gt;'&#125;        onReady=&#123;editor =&gt; &#123;          // You can store the \"editor\" and use when it is needed.          console.log('Editor1 is ready to use!', editor);        &#125;&#125;        // 相当于 editor.model.document.on(\"change:data\", handleChange)        onChange=&#123;handleChange&#125;        onBlur=&#123;handleBlur&#125;        onError=&#123;onError || console.error&#125;      /&gt;    &lt;/CKEditorContext&gt;  );&#125;export default CKEditor;\n\n关键属性如下：\n\neditor：使用的富文本编辑器模板\nconfig：富文本编辑器的配置项，默认会用Editor.defaultConfig配置好的\ndisabled: 富文本是否可编辑\ndata: 富文本的html字符串\nonReady: 编辑器刚构建好时会调用，官网推荐在这里将富文本做存储，避免重复构建\nonChange: 改变时调用\nonBlur: 焦点变化时调用\nonError: 出现错误时调用常见问题\n\n\n编辑器被重复引用：\n\n\n产生原因： \nconfig属性中有plugins属性，官网将对应的插件直接在组件引用\n\n\n\nimport Essentials from '@ckeditor/ckeditor5-essentials/src/essentials';import Bold from '@ckeditor/ckeditor5-basic-styles/src/bold';import Italic from '@ckeditor/ckeditor5-basic-styles/src/italic';import Paragraph from '@ckeditor/ckeditor5-paragraph/src/paragraph';const editorConfiguration = &#123;    plugins: [ Essentials, Bold, Italic, Paragraph ],    toolbar: [ 'bold', 'italic' ]&#125;;    &lt;CKEditor    editor=&#123; ClassicEditor &#125;    config=&#123; editorConfiguration &#125;    ...其他属性/&gt;\n\n\n问题链接:https://github.com/ckeditor/ckeditor5/issues/5776 \n解决方案：编写前文图例的ckeditor.js，然后将CkEditor组件需要的配置注入，实际编写的组件中引入对应js的文件，不需要的删除，目前没看到什么场景必须使用config.plugins \n\n\n打包内存溢出(我没遇到过)解决方案官网已经给出，链接如下：https://ckeditor.com/docs/ckeditor5/latest/installation/getting-started/frameworks/react.html#integrating-a-build-from-the-online-builder\n\n中文包全局引入\nimport \"@ckeditor/ckeditor5-build-classic/build/translations/zh-cn\"\nEditor.defaultConfig.language = 'zh-cn'\n\n自定义插件npm包的形式个人推荐使用ckeditor5-package-generator\n\nCkEditor5要求所有的插件包都必须以ckeditor5-开头，中间字符为0-9、a-z、. - _，创建和打包的时候都会正则校验 \n上述插件会提供一个打包模板，我们可以在这个模板上扩展，会有一个已经编写好的插件 \n\n详细的编写方式可见参考链接\n简述如下：\n\n一个插件就是一个继承于Plugin的class\neditor.ui.componentFactory负责添加一个工具，可以使用模型层的监听器为用户对工具栏上自定义ui定义其操作\n\n注意点：如果多个插件打包，并非工具生成的目录， 目录如下可以直接打包，也可以使用dll模式，这里推荐直接打包，webpack5自带缓存，dll不会对打包速度有明显的效果\n...|- src  |- ckeditor5-plugin1    |- lang      |- translations        |- zh-cn.po      |- contexts.json    |- src      |- index.js  |- ckeditor5-plugin2    |- lang      |- translations        |- zh-cn.po      |- contexts.json    |- src      |- index.js  |- ckeditor5-plugin3    |- lang      |- translations        |- zh-cn.po      |- contexts.json    |- src      |- index.js...\n\nimport Plugin from '@ckeditor/ckeditor5-core/src/plugin';class InsertImage extends Plugin &#123;    init() &#123;        const editor = this.editor;          // 为工具栏添加一个 insertImage，使用 imageIcon        editor.ui.componentFactory.add( 'insertImage', locale =&gt; &#123;            const view = new ButtonView( locale );            view.set( &#123;                label: 'Insert image',                icon: imageIcon,                tooltip: true            &#125; );            // 监听执行这个Button，会弹出输入url，监听模型层，根据输入的url展示对应的图片，并插入到模型层对应的鼠标 selection 节点上            view.on( 'execute', () =&gt; &#123;                const imageUrl = prompt( 'Image URL' );                editor.model.change( writer =&gt; &#123;                    const imageElement = writer.createElement( 'imageBlock', &#123;                        src: imageUrl                    &#125; );                    editor.model.insertContent( imageElement, editor.model.document.selection );                &#125; );            &#125; );            return view;        &#125; );    &#125;&#125;\n\n自定义扩展完整文档可见CKEditor提供了自定义扩展，根据先有的adapter做扩展，以下都将用Image Uploader做举例\n例如： Upload adapter作用是在文件编辑器和文件上传服务器之间构建一个桥梁，我们可以自定义扩展用户上传的行为以及上传到服务器的接口等，这个adapter是基于File repository plugin创建的，像image upload plugin也是基于这个创建的，``File repository plugin`是整个上传的核心插件。\n区别：自定义插件是完全从ui到功能的自定义实现自定义扩展是基于已有的富文本编辑器功能，做一些替换或者功能的提升\n工作流程\n首先，图像（或图像）需要进入富文本编辑器内容。有很多方法可以做到这一点，例如：\n\n\n从剪贴板粘贴图像\n从文件系统中拖动文件\n通过文件系统对话框选择图像，即选择上传\n\n这些行为都将被image uploader plugin插件捕获\n\n对于每个上传的图像都会被image upload plugin创建出file loader的实例，通过upload adapter将其上传到服务器，并根据url正确的展示在编辑器内 \n\n在上传图片时，image upload plugin会做以下事情 \n\n\n\n创建图像的占位符\n插入到编辑器\n展示每一个图像的进度条\n上传完成前如果做了删除图片的操作，终止上传\n\n\n图片上传完成，upload adapter通知editor（调用Promise），image upload创建的标签中的src和srcset将被替换\n\n扩展方式\nimage upload必须在编辑器中启用。它在所有官方版本中默认启用，如果正在自定义CKEditor 5编辑器，那么需要自己写这个插件\n\n需要自定义upload adapter，我们可以根据使用已有的upload adapter，也可以自定义（建议自定义，将上传和回显操作控制在自己手中）\n编写UploadAdapter\n自定义UploadAdapter，主要是自定义上传的服务器路径以及自定义回显方式 \n\n根据UploadAdapter参考链接`可以找到对应的方法 \n\n\n\nupload()返回一个Promise \nabort()上传中止所做的操作 \n\n\n通常我们使用XMLHttpRequest在这个UploadAdapter中，详细请见创建一个简易的UploadAdapter，完整代码如下\n\nclass MyUploadAdapter &#123;    constructor(loader) &#123;        // The file loader instance to use during the upload.        this.loader = loader;    &#125;    // Starts the upload process.    upload() &#123;        return this.loader.file.then(            (file) =&gt;                new Promise((resolve, reject) =&gt; &#123;                    this.initRequest();                    this.initListeners(resolve, reject, file);                    this.sendRequest(file);                &#125;),        );    &#125;    // Aborts the upload process.    abort() &#123;        if (this.xhr) &#123;            this.xhr.abort();        &#125;    &#125;    // Initializes the XMLHttpRequest object using the URL passed to the constructor.    initRequest() &#123;        this.xhr = new XMLHttpRequest();        // Note that your request may look different. It is up to you and your editor        // integration to choose the right communication channel. This example uses        // a POST request with JSON as a data structure but your configuration        // could be different.        this.xhr.open('POST', '/api/img/upload', true);        this.xhr.responseType = 'json';        // 设置请求头（权限控制）        this.xhr.setRequestHeader('AUTHENTICATION', '111');    &#125;    // Initializes XMLHttpRequest listeners.    initListeners(resolve, reject, file) &#123;        const &#123; xhr, loader &#125; = this;        const genericErrorText = `Couldn't upload file: $&#123;file.name&#125;.`;        xhr.addEventListener('error', () =&gt; reject(genericErrorText));        xhr.addEventListener('abort', () =&gt; reject());        xhr.addEventListener('load', () =&gt; &#123;            const &#123; response &#125; = xhr;            // This example assumes the XHR server's \"response\" object will come with            // an \"error\" which has its own \"message\" that can be passed to reject()            // in the upload promise.            //            // Your integration may handle upload errors in a different way so make sure            // it is done properly. The reject() function must be called when the upload fails.            if (!response || response.error) &#123;                return reject(                    response &amp;&amp; response.error ? response.error.message : genericErrorText,                );            &#125;            // If the upload is successful, resolve the upload promise with an object containing            // at least the \"default\" URL, pointing to the image on the server.            // This URL will be used to display the image in the content. Learn more in the            // UploadAdapter#upload documentation.            return resolve(&#123;                default: response.data,            &#125;);        &#125;);        // Upload progress when it is supported. The file loader has the #uploadTotal and #uploaded        // properties which are used e.g. to display the upload progress bar in the editor        // user interface.        if (xhr.upload) &#123;            xhr.upload.addEventListener('progress', (evt) =&gt; &#123;                if (evt.lengthComputable) &#123;                    loader.uploadTotal = evt.total;                    loader.uploaded = evt.loaded;                &#125;            &#125;);        &#125;    &#125;    // Prepares the data and sends the request.    sendRequest(file) &#123;        // Prepare the form data.        const data = new FormData();        data.append('attach', file);        // Important note: This is the right place to implement security mechanisms        // like authentication and CSRF protection. For instance, you can use        // XMLHttpRequest.setRequestHeader() to set the request headers containing        // the CSRF token generated earlier by your application.        // Send the request.        this.xhr.send(data);    &#125;&#125;export default MyUploadAdapter;\n","categories":["React"],"tags":["前端","CKEditor"]},{"title":"浏览器八股文(持续更新)","url":"/2022/06/17/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%AB%E8%82%A1%E6%96%87/","content":"只针对自己不太熟或者面试常问的有针对性的整理\n浏览器架构现代浏览器的多进程架构如下\n\n多进程架构的优势：\n各个进程相互独立，不会互相影响，不会因为一个进程的崩溃而影响整个浏览器的运行\n浏览器主进程: 负责各个页面的展示交互\n渲染进程: js引擎等\nGPU进程：绘制ui界面\n网络进程: 负责网络资源加载，浏览器的跨域从渲染进程发起，被网络进程拦截\n插件进程: 负责插件运行\nJavaScript单线程模型\nGUI线程与js引擎线程互斥\n\njs会阻塞页面加载\n\nwebWorker可以再开启一个线程，但是这个线程由主线程控制，且不能操作DOM，但是webWorker需要通信，通信时长如果大于线程执行之间将得不偿失。\n\n\n渲染机制基本流程\n\n解析HTML生成DOM树\n\n\n期间如果遇到脚本(js或者其他)那么暂停解析，加载脚本，加载完重新构建DOM树\n\n\n解析CSS生成CSSOM树\n\nDOM树和CSSOM树合并生成渲染树\n\n渲染树进行布局layout，计算节点的位置大小等等\n\n调用GPU绘制，这个过程称为重绘\n\n\n重绘回流基本概念回流：会计算布局的大小位置，重新生成渲染树\n\n局部回流: 外层dom大小位置不变化，只变化了内层的\n\n全局范围：从根节点开始回流\n\n\n重绘：只更改外观，不更改布局\n针对回流优化\n不要直接修改DOM中会改变定位或者大小的属性\n\n不要过度的获取计算DOM的位置，大小\n\nvisibility取代display: none\n\n频繁运行的动画使用requestAnimationFrame或者变成一个新的图层\n\n\n变图层的方式: \n\n3D 变换：translate3d、translateZ\n\nwill-change\n\nvideo、iframe 标签\n\nposition: fixed\n\n\n与EventLoop的关系requestAnimationFrame是一个能让js线程和浏览器交互的方法，这个函数传入的方法可以在浏览器重绘前调用,下面写一个简单的demo，让浏览器自己决定函数的触发时机保证不卡顿\nlet count = 0;let start = 0;let ref;function animation(temp)&#123;    if(temp - start &gt; 100)&#123;        start = temp;        count++    &#125;    ref = window.requestAnimationFrame(animation)&#125;ref = window.requestAnimationFrame(animation)\n\n其余渲染优化\nscript标签尽量放在后面，最好支持异步加载，最好支持延迟加载\n\n尽可能快的加载CSS样式表，避免js加载时样式表还没加载完\n\n适当使用图层\n\n\n\n浏览器标准流可以视为一个图层，我们可以手动创建图层，脱离标准流，脱离标准流的图层会单独渲染，因此如果遇到渲染麻烦的图层我们可以单独为其创建一个图层渲染，但是不要过度使用，渲染本身也耗性能\n\n注意点：\n\nCSSOM树的构建会影响渲染树的生成，因此CSS会影响页面渲染\n\nHTML标签遇到script标签会暂停构建，加载完后再去构建DOM\n\nscript标签引入的js文件，也需要在css样式表加载完之后才会执行\n\n\nLoad 和 DOMContentLoadedLoad是等HTML、CSS、JS、图片等资源都加载完时触发，可以用来计算首屏渲染时间\nDOMContentLoaded是HTML解析完成触发，不需要等待CSS、JS、图片\n浏览器缓存强缓存：Cache-Control 和 Expire\n协商缓存：If-none-match配合Etag 和 If-modified-since配合last-modified\n优先强缓存，然后协商缓存\n存储方案Cookie：小 4k左右、会带到请求头localStorage： 5m，需要手动清理sessionStorage 5m，一直存在\n跨域详细看HTTP\n安全(XSS和CSRF)XSS：代码注入\n\n持久型：数据库代码注入\n非持久: url代码注入(浏览器自动防范)\n\nCSP: 白名单(设置外部资源访问限制)，meta标签可以做&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;\nCSRF: 跨站请求伪造，本站请求黑客服务器的方式来获取用户的信息\n\ncookie设为同域\n请求带上token从输入URL到页面展示的过程(经典面试题)\n\n\n合成url，判断是否是一个合法的域名，非合法就调用浏览器默认搜索功能，合法就跳转到对应的网站\nDNS检索，检索优先从缓存中拿(浏览器缓存中 -&gt; 本地HOST -&gt; 本地DNS解析缓存 -&gt; 本地DNS服务器)，缓存中如果没有，依次查找根域名服务器、顶级域名服务器、二级域名服务器\n建立TCP连接，TCP连接主要是三次握手\n\n\n第一次：客户端发送标记位SYN, seq = p\n第二次：服务端响应ACK，ack = p + 1，请求建立连接标记位SYN seq = q\n第三次: 客户端响应标记位为ACK ack = q + 1\n\n\n获取文件，优先从缓存中获取文件，优先强缓存，然后协商缓存\n\n断开连接，TCP四次挥手\n\n\n\n客户端发出标记位FIN，请求关闭\n服务端发送标记位ACK，表示收到\n服务端发出标记位FIN，表示可以关闭\n客户端发出标记位ACK，表示收到\n客户端等待两个MSL后断开连接\n\n\n获取文件后，解析HTML，渲染页面\n\n\n解析HTML，生成 DOM 树， 解析CSS，生成CSSOM树\n合并生成render树\n交由GPU渲染页面\n交给浏览器绘制展示到页面上图层\n\n层叠上下文是HTML元素的三维概念，这些HTML元素在一条假想的相对于面向（电脑屏幕的）视窗或者网页的用户的z轴上延伸，HTML元素依据其自身属性按照优先级顺序占用层叠上下文的空间。\n拥有层叠上下文属性的元素会被提升为单独的一层。拥有层叠上下文属性：\n\n根元素 (HTML),\nz-index 值不为 &quot;auto&quot;的 绝对/相对定位元素，\nposition,固定（fixed） / 沾滞（sticky）定位（沾滞定位适配所有移动设- 备上的浏览器，但老的桌面浏览器不支持）\nz-index值不为 &quot;auto&quot;的 flex 子项 (flex item)，即：父元素 - display: flex|inline-flex，\nz-index值不为&quot;auto&quot;的grid子项，即：父元素display：grid\nopacity 属性值小于 1的元素（参考 the specification for - opacity），\ntransform 属性值不为 &quot;none&quot;的元素，\nmix-blend-mode 属性值不为 &quot;normal&quot;的元素，\nfilter值不为&quot;none&quot;的元素，\nperspective值不为&quot;none&quot;的元素，\nclip-path值不为&quot;none&quot;的元素\nmask / mask-image / mask-border不为”none”的元素\nisolation 属性被设置为 &quot;isolate&quot;的元素\n在 will-change 中指定了任意CSS属性\n-webkit-overflow-scrolling 属性被设置 “touch”的元素\ncontain属性值为&quot;layout&quot;，&quot;paint&quot;，或者综合值比如&quot;strict&quot;，&quot;content&quot;\n\nrequestAnimationFrame 和 requestIdleCallbackrequestAnimationFrame浏览器渲染前调用，60刷新率大概为16.7ms\nrequestIdleCallback，浏览器两帧间的空闲时间调用\n","categories":["面试"],"tags":["面试"]},{"title":"webpack基本配置","url":"/2020/11/29/webpack/","content":"基本搭建npm init -y\n一顿yes直接搭建好基本的node环境\nyarn install webpack webpack-cli --save-dev\n安装webpack, webpack-cli, 由于是开发环境需要,加上–save-dev\nmodule.exports = &#123;    entry: \"./index.js\",    mode: \"development\",    output: &#123;        path: path.resolve(__dirname, 'dist'),    &#125;,&#125;\n新建index.js, 新建webpack.config.js, webpack默认读取webpack.config.js导出的对象.\nnpx webpack\nwebpack默认读取根路径下的webpack.config.js文件, npm5.2之后提供了自动安装npx ,会自动查找当前依赖包中的可执行文件并执行\n\n\n\ncontext定义了打包的基础目录, 一旦设置, 那么接下来配置设置的根路径将会是配置的基础目录。\nconst path = require('path');module.exports = &#123;  //...  context: path.resolve(__dirname, 'app')&#125;;\n\n\nentry文件打包的起点\n\n可以传入数组, 传入数组从前往后依次进行打包, 包名为main\n可以传入对象, 每个键作为打包的包名， 值为打包的资源路径或者打包的描述符module.exports = &#123;  //...  entry: './index.js'&#125;;// 也可以自定义包名module.exports = &#123;  //...  entry: &#123;    app: './app.js',    home: &#123; import: './contact.js', filename: 'pages/[name][ext]' &#125;,    about: &#123; import: './about.js', filename: 'pages/[name][ext]' &#125;  &#125;&#125;;\n多入口可以设置打包依赖， 减少包体积， 避免重复使用相同的包module.exports = &#123;  //...  entry: &#123;    app: &#123; import: ['./app.js', './app2.js'], dependOn: 'react-vendors' &#125;,    'react-vendors': ['react', 'react-dom', 'prop-types']  &#125;&#125;;\n可以动态引入， 将在make事件中触发module.exports = &#123;  //...  entry: () =&gt; './demo' // () =&gt; new Promise((resolve) =&gt; resolve(['./demo', './demo2']))&#125;;\n\n\n\n\nmode打包模式分为development和production\nmodule.exports = &#123;  //...  mode: 'development' // 'production'&#125;;\n可以在打包时决定\nnpx webpack --mode&#x3D;development\n\n如果我们需要在不同模式下进行定义不同的打包行为， 我们可以定义为函数， 使用方法如下。\n开发环境打包文件webpack.base.js\nmodule.exports = (options) =&gt; (&#123;    // 这里注入基本配置&#125;)\n主打包文件webpack.dev.js\nmodule.exports = require('./webpack.base.js')(&#123;    // 这里将开发环境打包需要的配置注入&#125;)\n通过配置进行打包， 选择对应的打包文件\nwebpack --config webpack.dev.js\n\n\noutput打包的输出形态， 包括bundle和静态文件\nfilenamefilename 是一个很常见的配置，就是对应于 entry 里面的输入文件。\n这里可以使用可替换模板字符串的形式定义输出的打包文件名，浏览器存在缓存机制，如果名称相同，浏览器默认文件没有改变，这样打包文件名相同会使得获取文件出现问题，因此我们通过可替换模板字符串的形式定义输出的打包文件名。\n\n编译层\nname： chunk文件名\n\n\nchunk层\nid: 内部chunk的id\nchunkhash：这个chunk的hash值\n\n\n模块层\ncontenthash： 根据内容生成的hash\nid：模块id\nhash：模块的hash值\n\n\n文件层：\nfile： 文件名称和路径\nquery： 带前缀 ? 的 query\n\n\nurl层：\nurl\n\n\n\n\n具体参照模板字符串替换\n\nchunkFilenamechunkFilename 指未被列在 entry 中，却又需要被打包出来的 chunk 文件的名称。一般来说，这个 chunk 文件指的就是要懒加载的代码。\n注意点： 默认文件输出为[id].js或者遵循output.filename的设置，如果output.filename设置了name， 则会被预先替换为id\n\n可以参照这篇文章看到filename和chunkFilename的区别\n\npath打包文件路径\npublicPath外部资源路径，通常以/结尾, 默认参照路径为HTML页面所在的路径为准\n例如如下配置，请求一个chunk就相当于请求/assets/1.chunk.js\nmodule.exports = &#123;  //...  output: &#123;    publicPath: '/assets/',    chunkFilename: '[id].chunk.js'  &#125;&#125;;\n\nlibrary组织打包的模块，库开发使用\nlibraryTarget库打包引入的方式\n\nModulemodule对象用于模块的处理方式\nrules对应值为[Rule]数组rules作用在于提供模块的创建规则，提供对应的loader和解析器(parser)\nRuleRule是一个对象，这个对象分为三部分\n\n条件匹配： 条件匹配通过 test 、 include 、 exclude 和 resource 对资源进行匹配(这个资源指的是请求的资源)，并且属性 issuer 对 issuer 匹配, 这个 issuer 指的是请求者的文件绝对路径。是导入时的位置。\n应用规则： 对选中的文件使用 use 来应用 loader，按照从后往前的顺序应用， 并可以为loader传递参数。\n嵌套规则：父规则(文档这里没怎么理解, 在我看来是指一般的规则)、 rule、oneOf的顺序，可以通过enforce强制修改顺序。\n\nmodule.exports = &#123;  //...  module: &#123;    rules: [ // 以下对象对应一个Rule      &#123;        test: /\\\\.css$/, // loader1      &#125;,      &#123;          test: /\\\\.js$/, // loader2      &#125;    ]  &#125;&#125;;\n\n\n注意： loader 顺序从右往左，从下往上执行，按照 pitching 顺序执行|- a-loader `pitch`  |- b-loader `pitch`    |- c-loader `pitch`      |- requested module is picked up as a dependency    |- c-loader normal execution  |- b-loader normal execution|- a-loader normal execution\n\n\n\nRule.oneOf一旦匹配，就使用\nmodule.exports = &#123;  //...  module: &#123;    rules: [ // 以下对象对应一个Rule      &#123;        test: /\\\\.css$/,        oneOf: [            &#123;                resourceQuery: /inline/, // foo.css?inline                use: 'url-loader'            &#125;,            &#123;                resourceQuery: /external/, // foo.css?external                use: 'file-loader'            &#125;        ]      &#125;    ]  &#125;&#125;;\n\nRule.use提供一个 loader 数组, 从右往左进行匹配\nmodule.exports = &#123;  //...  module: &#123;    rules: [      &#123;        //...        use: [          'style-loader',          &#123;            loader: 'css-loader',            options: &#123;              importLoaders: 1            &#125;          &#125;,          &#123;            loader: 'less-loader',            options: &#123;              noIeCompat: true            &#125;          &#125;        ]      &#125;    ]  &#125;&#125;;\n\nRule.exclude/include排除/包括 loader 加载某个模块\nRule.parse文件被 loader 执行后会转成一段js字符串， parse会将其转换为 AST 语法树，有了语法树就可以对代码为所欲为了，其中最重要的功能就是分析出这段代码依赖了哪些模块\nRule.sideEffect模块是否包含副作用\nRule.type设置匹配模块的类型，防止 webpack 自定义的行为发生，常用于自定义loader加载模块\nRule.resolve模块解析可以在模块层被配置, Rule层面的 resolve 会覆盖顶层的 resolve配置\nUseEntryRule 传入的形式，通常可以是对象或者一个函数, 一个必选的字符串形式的 loader 和一个可选的 option\n函数形式则会接受一个加载模块的对象参数\n// 对象形式module.exports = &#123;  //...  module: &#123;    rules: [      &#123;        loader: 'css-loader',        options: &#123;          modules: true        &#125;      &#125;    ]  &#125;&#125;;// 函数形式module.exports = &#123;  //...  module: &#123;    rules: [      &#123;        loader: 'file-loader',        options: &#123;          outputPath: 'svgs'        &#125;      &#125;,      (info) =&gt; (&#123;        loader: 'svgo-loader',        options: &#123;          plugins: [&#123;            cleanupIDs: &#123; prefix: basename(info.resource) &#125;          &#125;]        &#125;      &#125;)    ]  &#125;&#125;;\n\nnoParse不解析所传递的正则表达式匹配到的文件，这里特别注意不匹配的文件不能存在require和import\nmodule.exports = &#123;  //...  module: &#123;    noParse: /jquery|lodash/,  &#125;&#125;;\n\nunsafeCache缓存模块是否需要解析， 首先得保证缓存开启。缓存未开启，默认为false。缓存开启，默认会解析node_modules的模块。\nmodule.exports = &#123;  //...  module: &#123;    cache: true,    // unsafeCache  &#125;&#125;;\n\nResolveresolve的作用在于如何正确的识别模块，找到需要引入bundle的模块代码\nalias创建别名，使得引入方式更加简单\n也可以在给定对象的键后的末尾添加 $，以表示精准匹配\n也可以使用 { &#39;路径&#39;: false } 表示忽略路径的模块\n\nresolve.alias 优先级高于其它模块解析方式。 \n\nconst path = require('path');module.exports = &#123;  //...  resolve: &#123;    alias: &#123;      Utilities: path.resolve(__dirname, 'src/utilities/'),      Templates: path.resolve(__dirname, 'src/templates/'),    &#125;,  &#125;,&#125;;// 原本方式import Utility from '../../utilities/utility';// 现阶段方式import Utility from 'Utilities/utility';\n\nOptimization优化，会根据打包模式自动切换配置，也可以手动配置\nminimize开启表示需要压缩，需要配合 TerserPlugin 或其它在 optimization.minimizer 定义的插件压缩 bundle\nminimizer使用自定义压缩工具，覆盖默认压缩工具，通常使用 TerserPlugin\nmodule.exports = &#123;    optimization: &#123;    minimizer: [      new TerserPlugin(&#123;        cache: true,        parallel: true,        sourceMap: true, // 如果在生产环境中使用 source-maps，必须设置为 true        terserOptions: &#123;          // https://github.com/webpack-contrib/terser-webpack-plugin#terseroptions        &#125;      &#125;),    ],  &#125;&#125;\n函数形式，形参为 compiler\nmodule.exports = &#123;  optimization: &#123;    minimizer: [      (compiler) =&gt; &#123;        const TerserPlugin = require('terser-webpack-plugin');        new TerserPlugin(&#123; /* 你的选项 */ &#125;).apply(compiler);      &#125;    ],  &#125;&#125;;\n\nsplitChunks默认使用 webpack4默认的分块策略，具体手动配置参考 splitChunkPlugin\nruntimeChunkruntimeChunk作用在于将只含有runtime的入口文件单独打包一个文件， 所谓runtime就是指异步加载代码如import(&#39;./utils&#39;) =&gt; {}\nemitOnErrors编译时每当有错误时，会被 emit， 关键错误会被 emit 到代码中\ntodo\nPluginsDevServerDevtoolTargetswatchexternalsperformanceNodestats对象cache","categories":["webpack"],"tags":["前端","webpack"]}]